\documentclass[a4paper, 12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{float}

% Pour utiliser la font Fira
\usepackage[sfdefault,scaled=.85]{FiraSans}
\usepackage{newtxsf}

% Pour créer des tableaux
\usepackage{array}
\usepackage{makecell}

% Pour créer des graphiques
\usepackage{tikz}
\usepackage{caption}
\usepackage{subcaption}

% Pour des environement pour le code
\usepackage{listings}

% Pour la biblio
\usepackage{biblatex}
\addbibresource{biblio.bib}

% Def couleurs


\title{Rapport de stage}
\date{}
\author{Vincent CAUJOLLE}

\begin{document}
\maketitle
\newpage
\tableofcontents
\newpage
\listoffigures
\listoftables
\newpage

\section*{Glosaire}
\begin{enumerate}
	\item XOR ($\oplus$):\\
		
		\begin{table}[h]
		\center
		\begin{tabular}{|c|c|c|}
		\hline
			$a$ & $b$ & $a\oplus b$ \\ \hline\hline
			0 & 0 & 0 \\ \hline
			0 & 1 & 1 \\ \hline
			1 & 0 & 1 \\ \hline
			1 & 1 & 0 \\ \hline
		\end{tabular}
		\caption{table de vérité du XOR}
		\label{XOR_table}
		\end{table}

	\item byte: 8 bits	
\end{enumerate}
\newpage

\section{AES}
\noindent\emph{Toutes les informations qui m'ont permis d'écrir cette section sont directement tiré de \cite{courslong}.}\\

Face au manque de standard de chiffrement par block, NIST (National Institute of Standards and Technology) a lancé un concours en 1997 pour créer un nouveau standard de chiffrement: AES (Advance Encryption Strandard).

De là naît un nouvel algorithme inspiré de la proposition des cryptographes belge Joan Daemen et Vincent Rijmen. Il permet de chiffrer des blocks de 128 bits et existe sous trois variante :

\begin{table}[h]
\center
\begin{tabular}{|c|c|c|c|}
\hline
	\makecell{nom} & \makecell{taille de la clef \\ (bits)} & \makecell{taille des blocks \\ (bits)} & \makecell{nombre de rounds} \\ \hline\hline
	AES 128 & 128 & 128 & 10 \\ \hline
	AES 192 & 192 & 128 & 12 \\ \hline
	AES 256 & 256 & 128 & 14 \\ \hline
\end{tabular}
\caption{Variantes d'AES}
\label{AES-versions}
\end{table}

\noindent\emph{A partir de maintenant, pour fluidifier la lecture, AES 128 = AES)} \\ 

\noindent Remarque : à l'origine cet algorithme pouvait supporter des blocks de 128, 192 et 256 bits. Cette fonctionnalité n'à malheureusement pas été conservé par la NIST. Cette fonction aurait permis à AES d'être post quantique. \\ 

AES permute successivement son entrée (un block de 128 bits) avec une même permutation $\Pi$ (sauf au dernier round ou on utilse $\hat{\Pi}$). Cette permutation est inversible, ce qui permet de déchiffrer la sortie en remontant le processus d'AES. \\

On XOR la sortie de chaque round avec une clef $k_i$ (calculé à partir de la clef secrète de 128 bits). L'avantage du XOR est que  $\text{XOR}^2 = \text{id}$ (voir table \ref{XOR_table}). Donc il suffit de réutiliser XOR pour remonter AES.

\begin{figure}[h]
\centering
\begin{tikzpicture}[scale=.8]
	% textes
	\node[draw, rectangle, align=center] (input) at (0.2,0) {Entrée};

	\node[draw, scale=1.5, rectangle, align=center] (round1) at (3,0) {$\Pi$};
\node[below, scale=0.75] at (round1.south) {round 1};
	\node[align=center] (dots) at (5.5,0) {$\dots$};
	\node[draw, scale=1.5, rectangle, align=center] (round9) at (8,0) {$\Pi$};
	\node[below, scale=0.75] at (round9.south) {round 9};
	\node[draw, scale=1.5, rectangle, align=center] (round10) at (10.4,0) {$\hat{\Pi}$};
	\node[below, scale=0.75] at (round10.south) {round 10};
	
	\node[draw, rectangle, align=center] (output) at (13.2,0) {Sortie};

	% XOR
	\node[scale=1.5, align=center] (xor1) at (1.8,0) {$\oplus$};
	\node[scale=0.75] at (xor1.north) {$k_0$};
	\node[scale=1.5, align=center] (xor2) at (4.2,0) {$\oplus$};
	\node[scale=0.75] at (xor2.north) {$k_1$};
	\node[scale=1.5, align=center] (xor3) at (6.8,0) {$\oplus$};
	\node[scale=0.75] at (xor3.north) {$k_7$};
	\node[scale=1.5, align=center] (xor4) at (9.2,0) {$\oplus$};
	\node[scale=0.75] at (xor4.north) {$k_8$};
	\node[scale=1.5, align=center] (xor5) at (11.6,0) {$\oplus$};
	\node[scale=0.75] at (xor5.north) {$k_9$};

	% lignes
	\draw (input.east) -- (round1.west);
	\draw (round1.east) -- (dots.west);
	\draw (dots.east) -- (round9.west);
	\draw (round9.east) -- (round10.west);
	\draw (round10.east) -- (output.west);
\end{tikzpicture}
\caption{fonctionement d'AES}
\label{AES_fonctionnement}
\end{figure}

\subsection{Permutation $\Pi$}
Cette permutation est propre à AES (ne dépend pas de la clef secrète et peut être calculé à l'avance. Cela permet d'avoir un processus de chiffrement très efficace). Elle est le résultat de la composition de 3 sous-permutations (toutes inversible). Pour mieux comprendre comment ces 3 sous-permutations marchent, il faut réorganiser le block de 128 bits en une matrice de taille $4\times4$ où chaque cellule contient un byte.

\begin{figure}[h]
\centering
\begin{tikzpicture}
	% entrée
	\node[align=center] (s) at (0,0) {$s_0|s_1|\dots|s_{15}$};
	
	% matrice
   	\foreach \y in {-1,0,1,2} {
        	\foreach \x in {2,3,4,5} {
            	\draw (\x, -\y) rectangle (\x+1, -\y+1);
            
            	\pgfmathtruncatemacro{\number}{(\y+1)*4 + \x -2}
		\node at (\x + 0.5, -\y + 0.5){$s_{\number}$};
        }

	% fleche
	\draw[->] (s.east) -- (1.8,0);
    }
\end{tikzpicture}
\caption{Réorganisation du block}
\label{reorg_entre}
\end{figure}

\begin{enumerate}
	\item $\mathtt{SubBytes}$: \\
		On applique à chaque cellule du block une permutation $S: \{0,1\}^8 \rightarrow \{0,1\}^8$ (d'un byte vers un autre).

		\begin{figure}[h]
		\centering
		\begin{tikzpicture}
			\foreach \y in {-1,0,1,2} {
			\foreach \x in {0,1,2,3} {
				\draw (\x, -\y) rectangle (\x+1, -\y+1);
			    
				\pgfmathtruncatemacro{\number}{(\y+1)*4 + \x }
				\node at (\x + 0.5, -\y + 0.5){$s_{\number}$};
			}}

			% matrice
			\foreach \y in {-1,0,1,2} {
			\foreach \x in {6,7,8,9} {
				\draw (\x, -\y) rectangle (\x+1, -\y+1);
			    
				\pgfmathtruncatemacro{\number}{(\y+1)*4 + \x-6}
				\node at (\x + 0.5, -\y + 0.5){$\tilde{s}_{\number}$};
			}}

			% fleche
			\draw[->] (4.5,0) -- (5.5,0) node[midway, above, scale=0.8] {$\mathtt{SubBytes}$};
		\end{tikzpicture}
		\caption{Effet de $\mathtt{SubBytes}$ sur le block, avec $\tilde{s} = S(s)$}
		\label{illu_subbyte}
		\end{figure}

		\begin{center}RAJOUTER DEF S\end{center}

	\item $\mathtt{ShiftRows}$: \\
		Cette permutation va pour chaque colone déplacer de manière cyclice ses élément de tel manière que la colone $i$ subira le cycle $$\left(0 \quad (1+i)\%4 \quad (2+i)\%4 \quad (3+i)\%4\right)$$

		\begin{figure}[H]
		\centering
		\begin{tikzpicture}
			\foreach \y in {-1,0,1,2} {
			\foreach \x in {0,1,2,3} {

				\draw (\x, -\y) rectangle (\x+1, -\y+1);
			    
				\pgfmathtruncatemacro{\number}{(\y+1)*4 + \x }
				\node at (\x + 0.5, -\y + 0.5){$s_{\number}$};
			}}

			% matrice
			\foreach \y in {-1,0,1,2} {
			\foreach \x in {6,7,8,9} {	
				\pgfmathtruncatemacro{\n}{(\y+2)*10}

				\fill[black!\n] (\x, -\y) rectangle (\x+1, -\y+1);
			    
				\pgfmathtruncatemacro{\number}{(\y+1)*4+\x-6}
				\pgfmathtruncatemacro{\nnumber}{\number+\y+1}
				\pgfmathtruncatemacro{\result}{
					mod(\nnumber, 4) + 4*(\y+1)
				}
				\node at (\x + 0.5, -\y + 0.5){$s_{\result}$};
			}}

			% fleche
			\draw[->] (4.5,0) -- (5.5,0) node[midway, above, scale=0.8] {$\mathtt{ShiftRows}$};
		\end{tikzpicture}
		\caption{Effet de $\mathtt{ShiftRows}$ sur le block}
		\label{illu_shiftrows}
		\end{figure}

	\item $\mathtt{MixColumns}$: \\
		Pour cette permutation, on calcul dans $GF\left(2^8\right)$ (muni du polynome iréductible $x^8 + x^4 + x^3 + x + 1$ ie $100011011$) le produit matriciel (à gauche) de notre block par:
		
		$$
		\begin{bmatrix}
			2 & 3 & 1 & 1 \\
			1 & 2 & 3 & 1 \\
			1 & 1 & 2 & 3 \\
			3 & 1 & 1 & 2 \\
		\end{bmatrix}
		$$
		
		avec les éléments de cette matrices à comprendre comme des éléments de $GF\left(2^8\right)$ 
\end{enumerate}

\noindent Donc, en résumé : 
$$
\begin{bmatrix}
	s_{0} & s_{1} & s_{2} & s_{3} \\
	s_{4} & s_{5} & s_{6} & s_{7} \\
	s_{8} & s_{9} & s_{10} & s_{11} \\
	s_{12} & s_{13} & s_{14} & s_{15} \\
\end{bmatrix}
\overset{\Pi}{\rightarrow}
\begin{bmatrix}
	2 & 3 & 1 & 1 \\
	1 & 2 & 3 & 1 \\
	1 & 1 & 2 & 3 \\
	3 & 1 & 1 & 2 \\
\end{bmatrix}
\times
\begin{bmatrix}
	\tilde{s}_0 & \tilde{s}_1 & \tilde{s}_2 & \tilde{s}_3 \\
	\tilde{s}_5 & \tilde{s}_6 & \tilde{s}_7 & \tilde{s}_4 \\
	\tilde{s}_{10} & \tilde{s}_{11} & \tilde{s}_8 & \tilde{s}_9 \\
	\tilde{s}_{15} & \tilde{s}_{12} & \tilde{s}_{13} & \tilde{s}_{14} \\
\end{bmatrix}
$$

\subsection{Permutation $\hat{\Pi}$}
Généralement on préfère utiliser $\hat{\Pi}$ au lieu de $\Pi$  au dernier round pour avoir un algorithme de déchiffrement quasiment identique que celui de chiffrement. Avec $\hat{\Pi}$ défini tel que :
$$
\begin{bmatrix}
	s_{0} & s_{1} & s_{2} & s_{3} \\
	s_{4} & s_{5} & s_{6} & s_{7} \\
	s_{8} & s_{9} & s_{10} & s_{11} \\
	s_{12} & s_{13} & s_{14} & s_{15} \\
\end{bmatrix}
\overset{\hat{\Pi}}{\rightarrow}
\begin{bmatrix}
	\tilde{s}_0 & \tilde{s}_1 & \tilde{s}_2 & \tilde{s}_3 \\
	\tilde{s}_5 & \tilde{s}_6 & \tilde{s}_7 & \tilde{s}_4 \\
	\tilde{s}_{10} & \tilde{s}_{11} & \tilde{s}_8 & \tilde{s}_9 \\
	\tilde{s}_{15} & \tilde{s}_{12} & \tilde{s}_{13} & \tilde{s}_{14} \\
\end{bmatrix}
$$
C'est exactement $\Pi$ mais sans la permutation $\mathtt{MixColumns}$. 

\subsection{Création des clefs $k_i$}\label{clefki}
A partir d'une clef secrète $k$ (de 128 bits) il faut créer une série de clefs $k_0\dots k_{10}$.
Pour ça on sépare cette clef en 4 mots de 32 bits (4 byte) chacun.

\begin{figure}[h]
\centering
\begin{tikzpicture}
	\node[align=center] (k) at (0,0) {$10110\dots0110$};
	\draw[thick] (-1.5,-0.5) -- (1.5,-0.5) node[midway, below, scale=0.8] {128 bits};
	
	\draw[->] (1.8,0) -- (2.5,0);
	
	\foreach \x in {3,4,5,6} {
		\pgfmathtruncatemacro{\n}{\x-3}
		\draw (\x, -0.5) rectangle (\x+1, 0.5);
		\node[align=center]  at (\x+0.5, 0) {$\omega_{\n}$};
	}
\end{tikzpicture}
\caption{réorganisation des clefs en suite de mots de 32 bits}
\label{illu_clef}
\end{figure}
On définit la première clef $k_0 = \fbox{$\omega_{0,0}|\omega_{0,1}|\omega_{0,2}|\omega_{0,3}$} = k$ (ie $k_0$ est égale à la clef secrète). Ensuite, on calcul $k_i = \fbox{$\omega_{i,0}|\omega_{i,1}|\omega_{i,2}|\omega_{i,3}$}$ en fonction de $k_{i-1}$ tel que:

$$
\forall i \in \{1,2,3\} \quad 
\begin{cases}
	\omega_{i,0} &= \omega_{i-1,0} \oplus g_i(\omega_{i-1,3}) \\
	\omega_{i,j} &= \omega_{i-1,j} \oplus \omega_{i,j-1} \quad \forall j \in \{1,2,3\} 
\end{cases}
$$

\noindent Avec $g: \{0,1\}^{32} \rightarrow \{0,1\}^{32}$ une fonction tirée des standards d'AES.

\section{AES CBC}\label{sectioncbc}
\noindent\emph{Toutes les informations qui m'ont permis d'écrir cette section sont directement tiré de \cite{courscourt}.}\\

A lui seul, AES ne permet de chiffrer que des blocks de 128 bits. On pourrait se dire qu'il suffit d'appliquer AES sur l'ensemble des blocks (c'est le mode ECB). 

\begin{figure}[h]
\centering
\begin{tikzpicture}
	% message clair
	\foreach \x in {0,2} {
		\pgfmathtruncatemacro{\n}{(\x)/2+1}
		\draw (\x, 0) rectangle (\x+2, 0.5);
		\node[align=center]  at (\x+1, 0.25) {$m_{\n}$};
	}
	\node[align=center]  at (5, 0.25) {$\dots$};

	% message caché
	\foreach \x in {0,2} {
		\pgfmathtruncatemacro{\n}{(\x)/2+1}
		\draw (\x, -2.5) rectangle (\x+2, -2);
		\node[align=center]  at (\x+1, -2.25) {$c_{\n}$};
	}
	\node[align=center]  at (5, -2.25) {$\dots$};
	
	\node[draw, rectangle, align=center] (e1) at (1,-1) {$\text{AES}_k$};
	\node[draw, rectangle, align=center] (e2) at (3,-1) {$\text{AES}_k$};

	\draw[line width = 0.6mm] (1,0) -- (e1.north);
	\draw[->, line width = 0.6mm] (e1.south) -- (1, -2);
	
	\draw[line width = 0.6mm] (3,0) -- (e2.north);
	\draw[->, line width = 0.6mm] (e2.south) -- (3, -2);
\end{tikzpicture}
\caption{Fonctionement d'AES ECB, avec $\text{AES}_k$ le chiffrement d'un bloc par AES avec la clef secrète $k$}
\label{ilu_ECB}
\end{figure}

Mais, si on utilise la même clef sur plusieurs blocks, le chiffré deviens est très facile à déchiffrer. Il faudrait donc autant de clefs que de blocks pour assurer un chiffrement sécurisé. Cela doublerai la taille du message chiffré et n'est donc pas utilisé. \\

Il faut donc rajouter une couche supplémentaire pour pouvoir utilser AES afin de chiffrer ce que l'on veut. On s'intéresse ici au mode CBC (Cipher Block Chaining). Son fonctionnement est décrit sur la figure \ref{ilu_cbc}

\begin{figure}[h]
\centering
\begin{subfigure}{\textwidth}
\centering
\begin{tikzpicture}
	% message clair
	\foreach \x in {0,2} {
		\pgfmathtruncatemacro{\n}{(\x)/2+1}
		\draw (\x, 0) rectangle (\x+2, 0.5);
		\node[align=center]  at (\x+1, 0.25) {$m_{\n}$};
	}
	\node[align=center]  at (5, 0.25) {$\dots$};

	% message caché
	\draw (-2,-3) rectangle (0,-2.5);
	\node[align=center]  at (-1, -2.75) {IV};
	\foreach \x in {0,2} {
		\pgfmathtruncatemacro{\n}{(\x)/2+1}
		\draw (\x, -3) rectangle (\x+2, -2.5);
		\node[align=center]  at (\x+1, -2.75) {$c_{\n}$};
	}
	\node[align=center]  at (5, -2.75) {$\dots$};
	
	\node[align=center, scale=1.5] (x1) at (0.5,-0.75) {$\oplus$};
	\node[draw, rectangle, align=center] (e1) at (0.5,-1.75) {$\text{AES}_k$};
	\node[align=center, scale=1.5] (x2) at (2.5,-0.75) {$\oplus$};
	\node[draw, rectangle, align=center] (e2) at (2.5,-1.75) {$\text{AES}_k$};


	\draw[->, line width = 0.6mm] (0.5,0) -- (x1.north);
	\draw[line width = 0.6mm] (x1.south) -- (e1.north);
	\draw[->, line width = 0.6mm] (e1.south) -- (0.5, -2.5);
	
	\draw[->, line width = 0.6mm] (2.5,0) -- (x2.north);
	\draw[line width = 0.6mm] (x2.south) -- (e2.north);
	\draw[->, line width = 0.6mm] (e2.south) -- (2.5, -2.5);
	

	\draw[->, line width = 0.6mm] (-0.5,-2.5) to[out=90, in=180] (x1.west);
	\draw[->, line width = 0.6mm] (1.5,-2.5) to[out=90, in=180] (x2.west);
	\node[align=center, scale=1.5, color=white] (xc) at (4.5,-0.75) {$\oplus$};
	\draw[->, line width = 0.6mm] (3.5,-2.5) to[out=90, in=180] (xc.west);

\end{tikzpicture}
\caption{Chiffrement}
\end{subfigure}

\begin{subfigure}{\textwidth}
\vspace{1cm}
\centering
\begin{tikzpicture}
	% message clair
	\draw (-2,0) rectangle (0,0.5);
	\node[align=center]  at (-1, 0.25) {IV};
	\foreach \x in {0,2} {
		\pgfmathtruncatemacro{\n}{(\x)/2+1}
		\draw (\x, 0) rectangle (\x+2, 0.5);
		\node[align=center]  at (\x+1, 0.25) {$c_{\n}$};
	}
	\node[align=center]  at (5, 0.25) {$\dots$};

	% message caché
	\foreach \x in {0,2} {
		\pgfmathtruncatemacro{\n}{(\x)/2+1}
		\draw (\x, -3) rectangle (\x+2, -2.5);
		\node[align=center]  at (\x+1, -2.75) {$m_{\n}$};
	}
	\node[align=center]  at (5, -2.75) {$\dots$};
	
	\node[draw, rectangle, align=center] (e1) at (0.5,-0.7) {$\text{AES}^{-1}_k$};
	\node[align=center, scale=1.5] (x1) at (0.5,-1.75) {$\oplus$};
	\node[draw, rectangle, align=center] (e2) at (2.5,-0.7) {$\text{AES}^{-1}_k$};
	\node[align=center, scale=1.5] (x2) at (2.5,-1.75) {$\oplus$};

	\draw[line width = 0.6mm] (0.5,0) -- (e1.north);
	\draw[->, line width = 0.6mm] (e1.south) -- (x1.north);
	\draw[->, line width = 0.6mm] (x1.south) -- (0.5, -2.5);
	
	\draw[line width = 0.6mm] (2.5,0) -- (e2.north);
	\draw[->, line width = 0.6mm] (e2.south) -- (x2.north);
	\draw[->, line width = 0.6mm] (x2.south) -- (2.5, -2.5);

	\draw[->, line width = 0.6mm] (-0.5,0) to[out=-90, in=180] (x1.west);
	\draw[->, line width = 0.6mm] (1.5,0) to[out=-90, in=180] (x2.west);
	\node[align=center, scale=1.5, color=white] (xc) at (4.5,-1.75) {$\oplus$};
	\draw[->, line width = 0.6mm] (3.5,0) to[out=-90, in=180] (xc.west);
\end{tikzpicture}
\caption{Déchiffrement}
\end{subfigure}
\caption{Fonctionement d'AES CBC, avec $\text{AES}_k$ le chiffrement d'un bloc par AES avec la clef secrète $k$}
\label{ilu_cbc}
\end{figure}

On remarque que le premier block du chiffré est un Initialization Vector (IV). C'est un block choisit aléatoirement. Ensuite, un deuxième point important de ce mode d'utilisation d'AES (ou de tout autre méthode de chiffrement par block) est qu'il faut que la taille du message en clair soit exactement un multiple de 128 bits. La solution pour palier à ce problème est de rajouter un padding. C'est à dire que l'on complète le message pour que sa taille soit exactement égale au prochain multiple de 128 bits (si le message fait est déjà un multiple de 128 bits on rajoute 16 byte de padding). Il peut prendre plein de forme différente, on peut compléter avec des $0$, des bits aléatoires... La seul règle importante est que le dernier byte du block doit contenir le nombre de byte de padding qui ont été rajouté (entre 0 et 15). \\

Pour ma part mon padding suivra la règle suivante : tous les bytes du padding ont la même valeurs (donc celle du denier byte).
Par exemple s'il manque 3 byte à mon message pour être un multiple de 16 byte (i.e 128 bites) alors je rajoute à la fin du message $\fbox{02|02|02}$. Si c'est déjà un multiple de 16 byte je rajoute à la fin\\ $\fbox{15|15|15|15|15|15|15|15|15|15|15|15|15|15|15|15}$.\\

J'avais essayé d'implémenter la padding classique (remplir de $0$, par exemple pour un padding de 3 bytes cela donne $\fbox{00|00|02}$) mais je devais mal implémenter quelque chose car je n'arrivais pas à me munir d'un padding oracle (voir \ref{padoracle}) alors que la théorie veux que ça ne change rien.

\subsection{Mon implémentation}
Dans le cade de ma mission je dois implémenter AES CBC en RUST. 
J'ai choisit de ne pas réimplémenter AES car j'avais du mal à implémenter des éléments relatif à $g$ (voir \ref{clefki}) mais aussi car une implémentation d'AES est très régulièrement inutilisable en réalité car trop facile à attaquer. Rien que des informations tels que la consomation électrique de l'ordinateur, le temps qu'il met à répondre ou encore le champ électromagnétique qu'il émet sont suffisant pour casser mon implémentation. 

J'ai donc implémenté le mode CBC avec le padding énnoncé à la fin de \ref{sectioncbc}. J'ai choisit pour simplifier la tache de me restreindre à chiffrer des chaines de charactères. De là est apparu un pseudo problème, le type Char en RUST peut faire de 1 à 4 byte. Mais,au déchiffrage, ne connaissant pas le nombre de byte associé à chaque charactères, j'ai été dans l'obligation de faire comme si chaque charactère ne faisait qu'un byte. Donc si mon message n'est pas uniquement écris avec des charactères ASCI (1 byte) alors j'aurais de la perte d'information. \\
Par exemple si je chiffre et déchiffre le message : "Je vais à l'école" j'obiendrai un message du type "Je vais \$£ l'\&ùcole".

J'ai choisit d'ignorer ce problème étant donné qu'il n'est du qu'au format de l'entrée.

\subsection{Pading oracle attack}\label{padoracle}
Dans cette section, j'explique comment j'ai attaqué AES CBC et de manière équivalente tout les modes de chiffrement non autentifié (qui ne fournissent pas une preuve d'autenticité du chiffré) et qui utilisent un padding. \\ 

L'attaque que j'ai mené repose sur un principe simple. Pour chaque algorithme de chiffrement qui utillisent un padding, n'importe qui pourra toujours avoir accès à un padding oracle (On n'a encore jamais trouvé de contre exemple). 

Avoir accès à un padding oracle c'est pouvoir déduire du comportement du serveur si le padding du message que je lui demande de déchiffrer est correct (on peut par exemple déduire cette information du temps que mets le serveur à nous répondre).
Je vais montré ci dessous qu'à partir du moment ou l'on a accès à ce genre d'information on peut casser le chiffré.

\subsubsection{Déchiffrer un block}
En reprenant la figure \ref{ilu_cbc} et en l'adaptant pour un block c on obtien la figure \ref{cbcdec1block}. 

\begin{figure}[h]
\centering
\begin{tikzpicture}
	\fill[red!20, opacity=0.5] (1.7,-0.1) rectangle (4.3,-3.35);
	% message clair
	\draw (0,0) rectangle (2,0.5);
	\node[align=center] at (1, 0.25) {IV};
	\draw (2,0) rectangle (4,0.5);
	\node[align=center] at (3,0.25) {c};

	% message caché
	\draw (2, -3) rectangle (4, -2.5);
	\node[align=center]  at (3, -2.75) {m};

	\node[draw, rectangle, align=center] (e2) at (3,-0.7) {$\text{AES}^{-1}_k$};
	\node[align=center, scale=1.5] (x2) at (3,-1.75) {$\oplus$};
	
	\draw[line width = 0.6mm] (3,0) -- (e2.north);
	\draw[->, line width = 0.6mm] (e2.south) -- (x2.north);
	\draw[->, line width = 0.6mm] (x2.south) -- (3, -2.5);

	\draw[->, line width = 0.6mm] (1,0) to[out=-90, in=180] (x2.west);

	\node[align=center] (pad_or) at (6,-2.75) {Padding Oracle};
	\draw[->, line width = 0.6mm] (4,-2.75) -- (pad_or.west);

\end{tikzpicture}
\caption{Déchiffrement d'un bloc, (en rouge: ce qui ne nous est pas accessible)}
\label{cbcdec1block}
\end{figure}

Le but de l'attaque est de trouver un IV tel que le padding du block déchiffré m est valide. En effet, si on arrive à trouver un IV tel que $m = \fbox{15|\dots|15}$ alors 
$$ 
\text{IV} \oplus \fbox{15|\dots|15} = \text{AES}^{-1}_{k}\left(\text{c}\right)
$$
On aura donc réussi à déchiffrer c! Pour arriver à trouver cet IV on procède de la manière suivante : \\

On pose IV = \fbox{00|00|00|00|00|00|00|00|00|00|00|00|00|00|00|b} avec b un byte quelconque. On fait varirer b (256 possibilités) jusqu'à obtenir une réponse positive du padding oracle. Une fois arrivé à cette étape il existe 2 situation dans lesquelle on peut se trouver :

\begin{enumerate}
	\item Dans le cas le plus courant on aura m = \fbox{??|??|$\dots$|??|00}. C'est ce qu'on cherche!
	\item Mais il se peut aussi que l'avant dernier byte permette à plus d'un padding d'être correcte. En effet, si ce byte vaut 01 alors il existe un byte b tel que l'IV produise un m = \fbox{??|??|$\dots$|??|01|01}.
\end{enumerate}

Ce deuxième cas est génant mais il est facile de vérifier dans quel cas on se trouve en modifiant l'avant dernier byte de l'IV.
En effet si en modifiant l'avant dernier byte de l'IV produit une réponse favorable du padding oracle cela signifie qu'on est dans le premier cas sinon on est dans le deuxième. 
\begin{align*}
	&\fbox{??|??|$\dots$|42|00} \rightarrow \text{padding valide}\\
	&\fbox{??|??|$\dots$|42|01} \rightarrow \text{padding invalide}
\end{align*}

Une fois à cette étape on peut créer un IV qu'on appelle ZIV (zeroing IV). Cet IV permet de mettre à 0 les bytes que l'on change dans m. Dans notre cas on a directement IV = ZIV. \\

On sait maintenant comment créer le premier ZIV, supposons que l'on soit cappable de créer le n-ième ZIV : $\text{ZIV}_n$ (cet IV assure que les n derniers bytes de m valent 0). Essayons de trouver $\text{ZIV}_{n+1}$. \\

On pose $\text{IV} = \text{ZIV}_n + \fbox{00|$\dots$|00|b|n|$\dots$|n}$ avec n bytes \fbox{n} et b, un byte quelconque. Cet IV permet d'avoir $\text{m} = \fbox{??|??|\dots|??|n|$\dots$|n}$ car 0 est l'élément neutre de $\oplus$ dans $\mathbb{Z}/2\mathbb{Z}$. \\
Comme à la première étape (celle qui sert à trouver le premier ZIV), on fait varier b (256 possiblités) jusqu'à avoir une réponse positive du padding oracle. En effectuant la même vérification qu'à la première étape, on est en mesure de trouver b tel que $\text{m} = \fbox{??|??|$\dots$|??|n|$\dots$|n|}$ avec cette fois ci n+1 byte \fbox{n}. Alors on remarque que $\text{ZIV}_{n+1} = \text{IV} \oplus \fbox{00|$\dots$|00|n|$\dots$|n}$ car $m \oplus \fbox{00|$\dots$|00|n|$\dots$|n} = \fbox{??|$\dots$|??|00|$\dots$|00}$. \\

Ainsi, on est en mesure de trouver un IV ($\text{ZIV}_{16}$) tel que $m=\fbox{00|$\dots$|00}$ et donc comme on l'a dit en début de section et comme on peut le voir sur la figure \ref{pad_ora_blo} on peut déchiffrer le block c car si $a \oplus b = 0$ alors $a = b$ donc $\text{AES}_k^{-1}(\text{c}) = \text{ZIV}_{16}$.

\begin{figure}[h]
\centering
\begin{tikzpicture}
	\fill[red!20, opacity=0.5] (1.7,-0.1) rectangle (4.3,-3.35);

	% message clair
	\draw (0,0) rectangle (2,0.5);
	\node[align=center, scale=0.8] at (1, 0.25) {$\text{AES}_k^{-1}(\text{c})$};
	\draw (2,0) rectangle (4,0.5);
	\node[align=center] at (3,0.25) {c};

	% message caché
	%\draw (2, -3) rectangle (4, -2.5);
	%\node[align=center]  at (3, -2.75) {$00|\dots|00$};
	\draw (2,-3) rectangle (2.66,-2.5) node[align=center] at (2.33,-2.75) {00};
	\draw (2.66,-3) rectangle (3.33,-2.5) node[align=center] at (3,-2.75) {$\dots$};
	\draw (3.33,-3) rectangle (4,-2.5) node[align=center] at (3.62,-2.75) {00};

	\node[draw, rectangle, align=center] (e2) at (3,-0.7) {$\text{AES}^{-1}_k$};
	\node[align=center, scale=1.5] (x2) at (3,-1.75) {$\oplus$};
	
	\draw[line width = 0.6mm] (3,0) -- (e2.north);
	\draw[->, line width = 0.6mm] (e2.south) -- (x2.north);
	\draw[->, line width = 0.6mm] (x2.south) -- (3, -2.5);

	\draw[->, line width = 0.6mm] (1,0) to[out=-90, in=180] (x2.west);

\end{tikzpicture}
\caption{Déchiffrement d'un bloc, (en rouge: ce qui ne nous est pas accessible)}
\label{pad_ora_blo}
\end{figure}

\subsubsection{Généralisation à n blocks}
On rappelle le shéma de déchifrement d'AES CBC sur la figure \ref{dechif_cbc}. On remarque alors que si on est en mesure de trouver $\text{AES}^{-1}_k(c_i)$ alors on est cappable de trouver $m_i$ $\forall i$. En effet $\text{AES}^{-1}_k(c_i) \oplus c_{i-1} = m_i$. Donc en déchiffran chaque block avec une attack par padding oracle on peut déchiffrer l'entierté du chiffré.   
\begin{figure}[h]
\centering
\begin{tikzpicture}
	\fill[red!20, opacity=0.5] (-0.7,-0.1) rectangle (5.5,-3.35);

	% message clair
	\draw (-2,0) rectangle (0,0.5);
	\node[align=center]  at (-1, 0.25) {IV};
	\foreach \x in {0,2} {
		\pgfmathtruncatemacro{\n}{(\x)/2+1}
		\draw (\x, 0) rectangle (\x+2, 0.5);
		\node[align=center]  at (\x+1, 0.25) {$c_{\n}$};
	}
	\node[align=center]  at (5, 0.25) {$\dots$};

	% message caché
	\foreach \x in {0,2} {
		\pgfmathtruncatemacro{\n}{(\x)/2+1}
		\draw (\x, -3) rectangle (\x+2, -2.5);
		\node[align=center]  at (\x+1, -2.75) {$m_{\n}$};
	}
	\node[align=center]  at (5, -2.75) {$\dots$};
	
	\node[draw, rectangle, align=center] (e1) at (0.5,-0.7) {$\text{AES}^{-1}_k$};
	\node[align=center, scale=1.5] (x1) at (0.5,-1.75) {$\oplus$};
	\node[draw, rectangle, align=center] (e2) at (2.5,-0.7) {$\text{AES}^{-1}_k$};
	\node[align=center, scale=1.5] (x2) at (2.5,-1.75) {$\oplus$};

	\draw[line width = 0.6mm] (0.5,0) -- (e1.north);
	\draw[->, line width = 0.6mm] (e1.south) -- (x1.north);
	\draw[->, line width = 0.6mm] (x1.south) -- (0.5, -2.5);
	
	\draw[line width = 0.6mm] (2.5,0) -- (e2.north);
	\draw[->, line width = 0.6mm] (e2.south) -- (x2.north);
	\draw[->, line width = 0.6mm] (x2.south) -- (2.5, -2.5);

	\draw[->, line width = 0.6mm] (-0.5,0) to[out=-90, in=180] (x1.west);
	\draw[->, line width = 0.6mm] (1.5,0) to[out=-90, in=180] (x2.west);
	\node[align=center, scale=1.5, opacity=0] (xc) at (4.5,-1.75) {$\oplus$};
	\draw[->, line width = 0.6mm] (3.5,0) to[out=-90, in=180] (xc.west);


\end{tikzpicture}
\caption{Déchiffrement d'AES CBC avec en rouge ce qui ne nous est pas accessible}
\label{dechif_cbc}
\end{figure}

\section{AES GCM}
\noindent\emph{Toutes les informations qui m'ont permis d'écrir cette section sont directement tiré de \cite{courscourt}.}\\


On s'est intéressé dans la section précédente au mode CBC en montrant qu'AES CBC était facilement attaquable et donc pas fiable. On s'intéresse ici au mode GCM (Galois Counter Mode), le mode d'utilisation le plus courant d'AES. Comme pour AES CBC, AES GCM fait des opérations sur des blocks de 128 bits pour permettre de chiffrer de grands fichier. Mais, à la différence d'AES CBC, AES GCM utilise un algorithme d'authentification en parallle du chiffrement ce qui permet d'assurer que le chiffré n'a pas été changé. Cette deuxième partie est essentielle car il a été montré qu'un algorithme de chiffrement non authentifié est quasiment systématiquement attaquable.

\subsection{CTR} \label{CTR}
Comme CBC, CTR (Counter) est un mode de manipulation des blocks qui permet de chiffrer des données avec des algorithme de chiffrement par blocks (comme AES) tout en garantisant un certain niveau de sécurité. CTR est le mode utilisé dans GCM mais sans l'authentification.Il est assez similaire à CBC mais à comme gros avantage de ne pas obliger de rajouter un padding à la fin des données clairs.

Son fonctionement est décrit sur la figure \ref{aesctr}. 

\begin{figure}[h]
\centering
\begin{tikzpicture}
	% message clair
	\foreach \x in {0,2} {
		\pgfmathtruncatemacro{\n}{(\x)/2+1}
		\draw (\x, 0) rectangle (\x+2, 0.5);
		\node[align=center]  at (\x+1, 0.25) {$m_{\n}$};
	}
	\node[align=center]  at (5, 0.25) {$\dots$};

	% message caché
	\draw (-2,-3.25) rectangle (0,-2.75);
	\node[align=center]  at (-1, -3) {IV};
	\foreach \x in {0,2} {
		\pgfmathtruncatemacro{\n}{(\x)/2+1}
		\draw (\x, -3.25) rectangle (\x+2, -2.75);
		\node[align=center]  at (\x+1, -3) {$c_{\n}$};
	}
	\node[align=center]  at (5, -3) {$\dots$};
	
	\node[draw, rectangle, align=center, scale = 0.75] (x1) at (1,-1.25) {$\text{AES}_k$};
	\node[align=center, scale=1.5] (e1) at (1,-2) {$\oplus$};
	\node[draw, rectangle, align=center, scale = 0.75] (x2) at (3,-1.25) {$\text{AES}_k$};
	\node[align=center, scale=1.5] (e2) at (3,-2) {$\oplus$};

	\draw[line width = 0.6mm] (x1.south) -- (e1.north);
	\draw[->, line width = 0.6mm] (e1.south) -- (1, -2.75);
	
	\draw[line width = 0.6mm] (x2.south) -- (e2.north);
	\draw[->, line width = 0.6mm] (e2.south) -- (3, -2.75);
	
	\node[align=center, scale = 0.75] (c1) at (1.5,-0.5) {$+1$};
	\node[align=center, scale = 0.75] (c2) at (3.5,-0.5) {$+1$};

	
	\draw[-, line width = 0.6mm] (-0.5,-2.75) -- (-0.5, -1);
	\draw[-, line width = 0.6mm] (-0,-0.5) -- (c1.west);
	\draw[-, line width = 0.6mm] (-0.5,-1) to[out=90, in=180] (0, -0.5);

	\draw[-, line width = 0.6mm] (c1.east) -- (c2.west);
	\draw[->, line width = 0.6mm] (c2.east) -- (4.5, -0.5);

	\draw[->, line width = 0.6mm] (0.5,-0.5) to[out=0, in=90] (x1.north);
	\draw[->, line width = 0.6mm] (2.5,-0.5) to[out=0, in=90] (x2.north);

	\draw[white, line width = 1mm] (0.1,-0.5) -- (0.3,-0.5);
	\draw[white, line width = 1mm] (2.1,-0.5) -- (2.3,-0.5);
	\draw[->, line width = 0.6mm] (0.25,0) to[out=270, in=180] (e1.west);
	\draw[->, line width = 0.6mm] (2.25,0) to[out=270, in=180] (e2.west);

\end{tikzpicture}
\caption{Fonctionnement d'AES CTR, avec $\text{AES}_k$ le chiffrement d'un bloc par AES avec la clef secrète $k$, \emph{Le +1 signifie qu'on incrémente de 1 l'IV généré aléatoirement.}
}
\label{aesctr}
\end{figure}

\subsection{GMAC} \label{GMAC}

Pour obtenir GCM il faut rajouter une étape d'authentification. Elle est fait par un algorithme incrémental GMAC (Galois Message Authentification Code). Cet algorithme produit au cours du chiffrement des blocks un Tag qui résume de manière sécurisé toutes les informations sur la donné à chiffré. L'intéret de cela est que chaque entrée produira un Tag unique. Donc si quelqu'un a modifié le chiffré, alors il y aura une erreur lors du déchiffrement.Cela permet de garantir que la donné que vous déchiffrez est bien celle que l'on souhaite récupérer.

\begin{figure}[h]
\centering
\begin{tikzpicture}

	% message caché
	\draw (-2,-3.25) rectangle (0,-2.75);
	\node[align=center]  at (-1, -3) {IV};
	\foreach \x in {0,2} {
		\pgfmathtruncatemacro{\n}{(\x)/2+1}
		\draw (\x, -3.25) rectangle (\x+2, -2.75);
		\node[align=center]  at (\x+1, -3) {$c_{\n}$};
	}
	\node[align=center]  at (5, -3) {$\dots$};
	\node[align=center] (x) at (5, -3.9) {$\dots$};
	\node[align=center] (xx) at (5, -5.2) {$\dots$};

	\draw (6, -3.25) rectangle (8, -2.75);
	\node[align=center]  at (7, -3) {$c_{n}$};
	\draw (8, -3.25) rectangle (10, -2.75);
	\node[align=center]  at (9, -3) {Tag};

	\node[draw, rectangle, align=center, scale = 0.75] (add) at (-1,-3.9) {AAD};
	\node[draw, rectangle, align=center, scale = 0.75] (len) at (7,-4.8) {Taille du chiffré et de l'AAD};

	
	\node[align=center] (x0) at (0,-3.9) {$\times \text{H}$};
	\node[align=center] (x1) at (1,-3.9) {$\bigoplus$};
	\node[align=center] (x2) at (2,-3.9) {$\times \text{H}$};
	\node[align=center] (x3) at (3,-3.9) {$\bigoplus$};
	\node[align=center] (x4) at (4,-3.9) {$\times \text{H}$};
	\node[align=center] (x5) at (6,-3.9) {$\times \text{H}$};
	\node[align=center] (x6) at (7,-3.9) {$\bigoplus$};
	\node[align=center] (x7) at (8,-3.9) {$\times \text{H}$};
	\node[align=center] (x8) at (9,-3.9) {$\bigoplus$};
	\node[align=center] (x9) at (10,-3.9) {$\times \text{H}$};
	\node[align=center] (x10) at (11,-3.9) {$\bigoplus$};

	\draw[-, line width = 0.6mm] (add.east) -- (x0.west);
	\draw[->, line width = 0.6mm] (x0.east) -- (x1.west);
	\draw[-, line width = 0.6mm] (x1.east) -- (x2.west);
	\draw[->, line width = 0.6mm] (x2.east) -- (x3.west);
	\draw[-, line width = 0.6mm] (x3.east) -- (x4.west);
	\draw[-, line width = 0.6mm] (x4.east) -- (x.west);
	\draw[-, line width = 0.6mm] (x.east) -- (x5.west);
	\draw[->, line width = 0.6mm] (x5.east) -- (x6.west);
	\draw[-, line width = 0.6mm] (x6.east) -- (x7.west);
	\draw[->, line width = 0.6mm] (x7.east) -- (x8.west);
	\draw[-, line width = 0.6mm] (x8.east) -- (x9.west);
	\draw[->, line width = 0.6mm] (x9.east) -- (x10.west);

	\node[draw, rectangle, align=center, scale = 0.75] (aesiv) at (3,-5.2) {$\text{AES}_k$};

	\draw[-, line width = 0.6mm] (-1.7, -3.25) -- (-1.7, -4.7);
	\draw[-, line width = 0.6mm] (-1.7, -4.7) to[out=270, in=180] (-1.2,-5.2);
	\draw[->, line width = 0.6mm] (-1.2,-5.2) -- (aesiv.west);
	\draw[-, line width = 0.6mm] (aesiv.east) -- (xx.west);
	\draw[-, line width = 0.6mm] (xx.east) -- (10.5,-5.2);
	\draw[->, line width = 0.6mm] (10.5,-5.2) to[out=0, in=270] (x10.south);

	\draw[->, line width = 0.6mm] (1, -3.25) -- (x1.north);
	\draw[->, line width = 0.6mm] (3, -3.25) -- (x3.north);
	\draw[->, line width = 0.6mm] (7, -3.25) -- (x6.north);
	\draw[->, line width = 0.6mm] (len.east) to[out=0, in=270] (x8.south);
	\draw[-, line width = 0.6mm] (x10.north) -- (11,-3.4);
	\draw[-, line width = 0.6mm] (11,-3.4) to[out=90, in=0] (10.5,-3);
	\draw[->, line width = 0.6mm] (10.5,-3) -- (10, -3);

\end{tikzpicture}
\caption{Fonctionnement du GMAC, avec $\text{AES}_k$ le chiffrement d'un bloc par AES avec la clef secrète $k$, et $\times \text{H}$ la multiplication dans $GF\left(2^{128}\right)$ par $\text{H} = \text{AES}_k\left({0}^{128}\right)$.}
\label{gmac}
\end{figure}

Dans la figure \ref{gmac}, une nouvelle entrée, appelée AAD (Additional Authenticated Data), est introduite. L'AAD est une donnée que l'on souhaite authentifier, mais pas nécessairement chiffrer. Par exemple, imaginons que vous envoyez un mot de passe accompagné d'une adresse web. Vous voudriez chiffrer le mot de passe pour le protéger, tout en laissant l'adresse en clair. Cependant, si l'adresse n'est pas authentifiée, un attaquant pourrait la modifier, et vous ne le sauriez pas lors du déchiffrement. L'AAD permet de protéger contre ce risque en garantissant que l'adresse n'a pas été altérée."

\subsection{GCM}

GCM est la combinaison du mode CTR (voir \ref{CTR}) et de la création d'un Tag avec GMAC (voir \ref{GMAC}). Combiné à AES, cela nous donne l'algorithme de chiffrement authentifié le plus largement utilisé. Son fonctionement est décrit sur la figure \ref{aesgcm}.

\begin{figure}[h]
\centering
\begin{tikzpicture}
	\fill[green!20, opacity=0.5] (-0.8,-0.2) rectangle (7.7,-2.55);
	\fill[red!20, opacity=0.5] (-2.2,-3.4) rectangle (11.5,-5.6);

	% message clair
	\foreach \x in {0,2} {
		\pgfmathtruncatemacro{\n}{(\x)/2+1}
		\draw (\x, 0) rectangle (\x+2, 0.5);
		\node[align=center]  at (\x+1, 0.25) {$m_{\n}$};
	}
	\node[align=center]  at (5, 0.25) {$\dots$};
	\node[align=center] (x) at (5, -0.5) {$\dots$};

	\draw (6, 0) rectangle (8, 0.5);
	\node[align=center]  at (7, 0.25) {$m_{n}$};
	
	\node[draw, rectangle, align=center, scale = 0.75] (x1) at (1,-1.25) {$\text{AES}_k$};
	\node[align=center] (e1) at (1,-2) {$\bigoplus$};
	\node[draw, rectangle, align=center, scale = 0.75] (x2) at (3,-1.25) {$\text{AES}_k$};
	\node[align=center] (e2) at (3,-2) {$\bigoplus$};
	\node[draw, rectangle, align=center, scale = 0.75] (x3) at (7,-1.25) {$\text{AES}_k$};
	\node[align=center] (e3) at (7,-2) {$\bigoplus$};



	\draw[line width = 0.6mm] (x1.south) -- (e1.north);
	\draw[->, line width = 0.6mm] (e1.south) -- (1, -2.75);
	
	\draw[line width = 0.6mm] (x2.south) -- (e2.north);
	\draw[->, line width = 0.6mm] (e2.south) -- (3, -2.75);

	\draw[line width = 0.6mm] (x3.south) -- (e3.north);
	\draw[->, line width = 0.6mm] (e3.south) -- (7, -2.75);
	
	\node[align=center, scale = 0.75] (c1) at (1.5,-0.5) {$+1$};
	\node[align=center, scale = 0.75] (c2) at (3.5,-0.5) {$+1$};
	
	\draw[-, line width = 0.6mm] (-0.5,-2.75) -- (-0.5, -1);
	\draw[-, line width = 0.6mm] (-0,-0.5) -- (c1.west);
	\draw[-, line width = 0.6mm] (-0.5,-1) to[out=90, in=180] (0, -0.5);

	\draw[-, line width = 0.6mm] (c1.east) -- (c2.west);
	\draw[-, line width = 0.6mm] (c2.east) -- (4.5, -0.5);

	\draw[->, line width = 0.6mm] (0.5,-0.5) to[out=0, in=90] (x1.north);
	\draw[->, line width = 0.6mm] (2.5,-0.5) to[out=0, in=90] (x2.north);
	\draw[-, line width = 0.6mm] (x.east) -- (6.5, -0.5);
	\draw[->, line width = 0.6mm] (6.5,-0.5) to[out=0, in=90] (x3.north);

	\draw[white, line width = 1mm] (0.1,-0.5) -- (0.3,-0.5);
	\draw[white, line width = 1mm] (2.1,-0.5) -- (2.3,-0.5);
	\draw[white, line width = 1mm] (6.1,-0.5) -- (6.3,-0.5);
	\draw[->, line width = 0.6mm] (0.25,0) to[out=270, in=180] (e1.west);
	\draw[->, line width = 0.6mm] (2.25,0) to[out=270, in=180] (e2.west);
	\draw[->, line width = 0.6mm] (6.25,0) to[out=270, in=180] (e3.west);


	% message caché
	\draw (-2,-3.25) rectangle (0,-2.75);
	\node[align=center]  at (-1, -3) {IV};
	\foreach \x in {0,2} {
		\pgfmathtruncatemacro{\n}{(\x)/2+1}
		\draw (\x, -3.25) rectangle (\x+2, -2.75);
		\node[align=center]  at (\x+1, -3) {$c_{\n}$};
	}
	\node[align=center]  at (5, -3) {$\dots$};
	\node[align=center] (x) at (5, -3.9) {$\dots$};
	\node[align=center] (xx) at (5, -5.2) {$\dots$};

	\draw (6, -3.25) rectangle (8, -2.75);
	\node[align=center]  at (7, -3) {$c_{n}$};
	\draw (8, -3.25) rectangle (10, -2.75);
	\node[align=center]  at (9, -3) {Tag};

	\node[draw, rectangle, align=center, scale = 0.75] (add) at (-1,-3.9) {AAD};
	\node[draw, rectangle, align=center, scale = 0.75] (len) at (7,-4.8) {Taille du chiffré et de l'AAD};

	
	\node[align=center] (x0) at (0,-3.9) {$\times \text{H}$};
	\node[align=center] (x1) at (1,-3.9) {$\bigoplus$};
	\node[align=center] (x2) at (2,-3.9) {$\times \text{H}$};
	\node[align=center] (x3) at (3,-3.9) {$\bigoplus$};
	\node[align=center] (x4) at (4,-3.9) {$\times \text{H}$};
	\node[align=center] (x5) at (6,-3.9) {$\times \text{H}$};
	\node[align=center] (x6) at (7,-3.9) {$\bigoplus$};
	\node[align=center] (x7) at (8,-3.9) {$\times \text{H}$};
	\node[align=center] (x8) at (9,-3.9) {$\bigoplus$};
	\node[align=center] (x9) at (10,-3.9) {$\times \text{H}$};
	\node[align=center] (x10) at (11,-3.9) {$\bigoplus$};

	\draw[-, line width = 0.6mm] (add.east) -- (x0.west);
	\draw[->, line width = 0.6mm] (x0.east) -- (x1.west);
	\draw[-, line width = 0.6mm] (x1.east) -- (x2.west);
	\draw[->, line width = 0.6mm] (x2.east) -- (x3.west);
	\draw[-, line width = 0.6mm] (x3.east) -- (x4.west);
	\draw[-, line width = 0.6mm] (x4.east) -- (x.west);
	\draw[-, line width = 0.6mm] (x.east) -- (x5.west);
	\draw[->, line width = 0.6mm] (x5.east) -- (x6.west);
	\draw[-, line width = 0.6mm] (x6.east) -- (x7.west);
	\draw[->, line width = 0.6mm] (x7.east) -- (x8.west);
	\draw[-, line width = 0.6mm] (x8.east) -- (x9.west);
	\draw[->, line width = 0.6mm] (x9.east) -- (x10.west);

	\node[draw, rectangle, align=center, scale = 0.75] (aesiv) at (3,-5.2) {$\text{AES}_k$};

	\draw[-, line width = 0.6mm] (-1.7, -3.25) -- (-1.7, -4.7);
	\draw[-, line width = 0.6mm] (-1.7, -4.7) to[out=270, in=180] (-1.2,-5.2);
	\draw[->, line width = 0.6mm] (-1.2,-5.2) -- (aesiv.west);
	\draw[-, line width = 0.6mm] (aesiv.east) -- (xx.west);
	\draw[-, line width = 0.6mm] (xx.east) -- (10.5,-5.2);
	\draw[->, line width = 0.6mm] (10.5,-5.2) to[out=0, in=270] (x10.south);

	\draw[->, line width = 0.6mm] (1, -3.25) -- (x1.north);
	\draw[->, line width = 0.6mm] (3, -3.25) -- (x3.north);
	\draw[->, line width = 0.6mm] (7, -3.25) -- (x6.north);
	\draw[->, line width = 0.6mm] (len.east) to[out=0, in=270] (x8.south);
	\draw[-, line width = 0.6mm] (x10.north) -- (11,-3.4);
	\draw[-, line width = 0.6mm] (11,-3.4) to[out=90, in=0] (10.5,-3);
	\draw[->, line width = 0.6mm] (10.5,-3) -- (10, -3);


\end{tikzpicture}
\caption{Fonctionnement d'AES GCM avec en vert CTR et en rouge GMAC}
\label{aesgcm}
\end{figure}


\noindent Pour résumer, AES GCM prend 4 entrées : 
\begin{enumerate}
	\item un nonce (ou IV) généré aléatoirement (que l'on choisit de mettre au début du chiffré pour réduir le nombre d'objets à stoquer).
	\item une clef (de préférence généré aléatoirement)
	\item des données à chiffrer et authentifier 
	\item des données à authentifier (on peut aussi ne pas en fournir)
\end{enumerate}
\noindent et fournit 2 sorties :
\begin{enumerate}
	\item Le chiffré de la donné à chiffrer
\item Le tag associé aux entrées (mis à la fin du chiffré)
\end{enumerate}
\section{SoftHSM}

Le but des cryptographe est de créer des problèmes facile à résoudre quand on a la clefs mais beaucoup trop long à casser le cas inverse. Donc, dans beaucoup de cas trouver un moyen de récupérer cette clef est beaucoup plus raisonnable que de chercher une faille dans le cryptosystème. Il faut donc trouver un moyen sécuriser de garder nos clefs, i.e il faut un coffre fort moderne. \\

Pour ça, il existe les HSM (Hardware Securty Module) qui sont des dispositif physique dédié à la gestion, au stockage et à la protection des clefs cryptographique. Il est conçu pour exécuter des opérations cryptographiques, telles que le chiffrement, le déchiffrement, la signature numérique et la gestion de clés, de manière sécurisée.


\begin{figure}[h]
	\centering
	\includegraphics[width=.7\textwidth]{img/hsm.png}
	\caption{HSM de Thales}
	\label{hsmthales}
\end{figure}

Ici on ne n'intéressera pas réellement aux HSM mais plutôt aux SoftHSM, une implémentation logicielle d'un HSM. Il permettent de développer des programmes, faire des tests en ammont d'une utilisation d'un HSM. \\

Dans un premier temps j'ai du me familiariser avec ce nouvel object, puis, j'ai du regarder les solutions en rust qui nous permettent de communiquer avec des HSM, les documenter et les tester (via un SoftHSM). \\


Pour communiquer avec un SoftHSM j'ai du me plonger dans la doc du logiciel. Avant de pouvoir entammer des opérations cryptographiques il faut créer un envronement dédié dans le SoftHSM. \\
Pour le créer la commande est la suivante :
\begin{verbatim}
sudo softhsm2-util --init-token 
		--slot <slot-num> 
		--token <token-label>
\end{verbatim}
et pour le supprimer :
\begin{verbatim}
sudo softhsm2-util --delete-token --label <token-label>
\end{verbatim}
Ici il faut bien comprendre qu'un token est une émulation d'un HSM (on peut émuler plusieur HSM sur un SoftHSM), le slot est un point d'entrée d'un HSM, il simule l'endroit ou l'on insère nos informations dans un HSM). \\
Après avoir initialiser mon softHSM, je peux communiquer avec lui en utilisant le standard pkcs11. C'est cette partie plus tard que je devrais programmer en rust. Pour le moment, j'utilise openssl, un logiciel qui me permet directement de communiquer avec le SoftHSM. Après avoir étudier la documentation, j'en ai tiré les informations suivantes :
Pour créer une clef je dois utiliser : 
\begin{verbatim}
sudo pkcs11-tool --module /usr/lib/softhsm/libsofthsm2.so 
		-l -p <usr-PIN> 
		--keygen --key-type <enc-mech> 
		--id <clef-id> 
		--label <clef-label>
\end{verbatim}
Avec <enc-mech> qui prend la forme AES:16, AES:32, ect. Pour la supprimer on utilise la commande : 
\begin{verbatim}
sudo pkcs11-tool --module /usr/lib/softhsm/libsofthsm2.so 
-l -p <usr-PIN> 
-b --type secrkey 
--id <clef-ID>
\end{verbatim}

Maintenant qu'on a réussit à créer des clefs, on peut les utiliser pour chiffrer et déchiffrer des données. Pour le faire, il faut utiliser :
\begin{verbatim}
sudo pkcs11-tool --module /usr/lib/softhsm/libsofthsm2.so 
		--login -p <usr-PIN> 
		--encrypt 
		--id <key-ID> 
		-m AES-CBC-PAD 
		--iv <iv-value> 
		-i <input file> 
		-o <output file>

sudo pkcs11-tool --module /usr/lib/softhsm/libsofthsm2.so 
		--login -p <usr-PIN> 
		--decrypt 
		--id <key-ID> 
		-m AES-CBC-PAD 
		--iv <iv-value> 
		-i <input file> 
		-o <output file>
\end{verbatim}

Pour la suite, j'utilise la crate cryptoki de Rust que j'ai trouvée grâce à \cite{bddrustcrypto}, ce qui me permet de garantir sa fiabilité.
La documentation de cette crate n'étant pas encore faite, j'ai créé un fichier tuto dans lequel je réalise toutes les opérations que je pourrais être amené à faire sur le SoftHSM, c'est-à-dire créer et supprimer des clés ainsi que chiffrer et déchiffrer des données. Pour y arriver, j'ai parcouru le code source de la documentation et je me suis aidé d'outils tels que ChatGPT. Après beaucoup d'essais, j'ai fini par obtenir un tutoriel fonctionnel.\\

La dernière étape consistait à vérifier que les résultats produits par mon programme correspondaient bien aux attentes. Pour cela, il est nécessaire de tester le programme avec des vecteurs de test. Chaque vecteur de test fournit une clé, un IV (Initialisation Vector), des données à chiffrer, le résultat chiffré attendu, et, si le programme le permet, des données à authentifier ainsi que le TAG correspondant. L'objectif de ces vecteurs est de comparer les sorties théoriques avec celles produites par notre algorithme. Pour que les tests soient validés, il faut que ces dernières soient identiques.

Pour faire ces test j'ai eu une grosse dificultée : je ne peux pas imposer la valeur d'une clef via mon programme (c'est une donnée protégé donc le softhsm me l'interdit). Pour contourner ce problème, je lance un script bash dans mon code rust qui crée la clef avec openssl. Ce script est le suivant : 
\begin{verbatim}
echo -n <key-value> > aes_key.txt
xxd -r -p aes_key.txt > aes_key.bin
sudo pkcs11-tool --module /usr/lib/softhsm/libsofthsm2.so 
		-l -p <usr-PIN> --write-object
aes_key.bin 
		--type secrkey --key-type <enc-mech> 
		--id <clef-id> 
		--label <clef-label>
\end{verbatim}
Mon programme à passé tout les test, et donc, grâce à mon tutoriel je suis maintenant capable de remplacer openssl par un programme "maison" en rust.
\section{Signature}
\subsection{RSA}
\subsection{Courbe elliptiques avec Ed25519}

\section{Mise en place d'un programme de chiffrement/déchiffrement}
\subsection{Contexte}
Maintenant que j'ai pris connaissance des algorithmes pour chiffrer et signer des données, je dois mettre en place une solution écrite en Rust qui permettra de chiffrer et de déchiffrer des fichiers. Cette solution devra permettre d'utiliser soit AES-GCM, soit ChaCha20-Poly1305 (un autre algorithme de chiffrement non détaillé précédemment).
Une optimisation que je pourrais envisager serait de proposer une version qui chiffrerait "au fil de l'eau", c'est-à-dire de manière progressive, bloc par bloc, à mesure que les données sont lues ou écrites. Cette méthode présente l'avantage de maintenir un coût constant en espace mémoire, car elle ne nécessite pas de charger l'intégralité du fichier en mémoire avant de le chiffrer. \\


Pour exécuter ce programme de chiffrement, il suffira d'utiliser les commandes suivantes :
\begin{verbatim}
cat clair.data | ./rucrypt options > enc.data
cat enc.data | ./rudecrypt options > dec.data
\end{verbatim}
Les options permettront de choisir l'algorithme utilisé. Pour le moment peuvent soit valoir "aes" pour AES-GCM, ou bien "cha" pour ChaCha20-Poly1305 ou encore "aes\_stream" pour la version au fil de l'eau d'AES-GCM.\\


\noindent\emph{le programme de chifrement s'appelle rucrypt et celui de déchifrement rudecrypt}

\subsection{Mise en place}
Cette fois-ci, contrairement à Ed25519, je n'ai pas tout reprogrammé. J'ai décidé d'utiliser des crates de confiance, largement éprouvées. Pour les identifier, je me suis aidé d'un site qui référence toutes les solutions couramment utilisées pour la cryptographie en Rust \cite{bddrustcrypto}. J'utilise AES 256 (voir le tableau \ref{AES-versions}). Pour chaque algorithme, je dois donc générer, avant le chiffrement, une clé de 32 octets (256 bits) et un nonce (vecteur d'initialisation) de 12 octets (96 bits). Il est démontré que cacher le nonce n'a aucun intérêt en termes de sécurité. Je place donc le nonce en clair avant le texte chiffré. \\

On pourrait s'arrêter là, mais il est possible d'ajouter un niveau de sécurité supplémentaire. Actuellement, le chiffrement et le déchiffrement se font avec une seule clé (c'est-à-dire une clé symétrique). Le problème de cette symétrie est que toute personne ayant accès à cette clé peut lire le message en clair. Dans le cadre de ma mission, cela représente une potentielle faille. En effet, le but final de ce programme est de permettre la création de sauvegardes chiffrées de données. Il est donc préférable d'utiliser une clé asymétrique (une pour le chiffrement et une pour le déchiffrement). Dans ce cas de figure, tout le monde peut effectuer une sauvegarde de ses fichiers, mais seules les personnes autorisées pourront les récupérer, cela permet de garder le contrôle sur les flux. Pour cette raison, je génère une clé privée et une clé publique RSA, avec laquelle je chiffre ma clé symétrique. Ainsi, seule la personne en possession de la clé privée pourra déchiffrer le document. Pour plus de simplicité, je place la clé symétrique chiffrée avant le nonce.


$$
\text{rucrypt(data)} \rightarrow \fbox{RSA(clef symétrique) | nonce | data chiffré}
$$


\printbibliography
\end{document}
