\documentclass[a4paper, 12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{float}

% Pour utiliser la font Fira
\usepackage[sfdefault,scaled=.85]{FiraSans}
\usepackage{newtxsf}

% Pour créer des tableaux
\usepackage{array}
\usepackage{makecell}

% Pour créer des graphiques
\usepackage{tikz}
\usepackage{caption}
\usepackage{subcaption}

% Pour des environement pour le code
\usepackage{listings}

% Pour la biblio
\usepackage{biblatex}
\addbibresource{biblio.bib}

% Def couleurs


\title{Rapport de stage}
\date{}
\author{Vincent CAUJOLLE}

\begin{document}
\maketitle
\newpage
\tableofcontents
\newpage
\listoffigures
\listoftables
\newpage

\section*{Glosaire}
\begin{enumerate}
	\item XOR ($\oplus$):\\
		
		\begin{table}[h]
		\center
		\begin{tabular}{|c|c|c|}
		\hline
			$a$ & $b$ & $a\oplus b$ \\ \hline\hline
			0 & 0 & 0 \\ \hline
			0 & 1 & 1 \\ \hline
			1 & 0 & 1 \\ \hline
			1 & 1 & 0 \\ \hline
		\end{tabular}
		\caption{table de vérité du XOR}
		\label{XOR_table}
		\end{table}

	\item byte: 8 bits	
\end{enumerate}
\newpage

\section{AES}
\noindent\emph{Toutes les informations qui m'ont permis d'écrire cette section sont directement tirées de \cite{courslong}.}\\

Face au manque de standard de chiffrement par bloc, NIST (National Institute of Standards and Technology) a lancé un concours en 1997 pour créer un nouveau standard de chiffrement: AES (Advanced Encryption Standard).

De là naît un nouvel algorithme inspiré de la proposition des cryptographes belge Joan Daemen et Vincent Rijmen. Il permet de chiffrer des blocs de 128 bits et existe sous trois variantes :

\begin{table}[h]
\center
\begin{tabular}{|c|c|c|c|}
\hline
	\makecell{nom} & \makecell{taille de la clef \\ (bits)} & \makecell{taille des blocs \\ (bits)} & \makecell{nombre de rounds} \\ \hline\hline
	AES 128 & 128 & 128 & 10 \\ \hline
	AES 192 & 192 & 128 & 12 \\ \hline
	AES 256 & 256 & 128 & 14 \\ \hline
\end{tabular}
\caption{Variantes d'AES}
\label{AES-versions}
\end{table}

\noindent\emph{A partir de maintenant, pour fluidifier la lecture, AES 128 = AES)} \\ 

\noindent Remarque : à l'origine cet algorithme pouvait supporter des blocs de 128, 192 et 256 bits. Cette fonctionnalité n'a malheureusement pas été conservé par la NIST. Cette fonction aurait permis à AES d'être post quantique. \\ 

AES permute successivement son entrée (un bloc de 128 bits) avec une même permutation $\Pi$ (sauf au dernier round ou on utilise $\hat{\Pi}$). Cette permutation est inversible, ce qui permet de déchiffrer la sortie en remontant le processus d'AES. \\

On XOR la sortie de chaque round avec une clef $k_i$ (calculé à partir de la clef secrète de 128 bits). L'avantage du XOR est que  $\text{XOR}^2 = \text{id}$ (voir table \ref{XOR_table}). Donc il suffit de réutiliser XOR pour remonter AES.

\begin{figure}[h]
\centering
\begin{tikzpicture}[scale=.8]
	% textes
	\node[draw, rectangle, align=center] (input) at (0.2,0) {Entrée};

	\node[draw, scale=1.5, rectangle, align=center] (round1) at (3,0) {$\Pi$};
\node[below, scale=0.75] at (round1.south) {round 1};
	\node[align=center] (dots) at (5.5,0) {$\dots$};
	\node[draw, scale=1.5, rectangle, align=center] (round9) at (8,0) {$\Pi$};
	\node[below, scale=0.75] at (round9.south) {round 9};
	\node[draw, scale=1.5, rectangle, align=center] (round10) at (10.4,0) {$\hat{\Pi}$};
	\node[below, scale=0.75] at (round10.south) {round 10};
	
	\node[draw, rectangle, align=center] (output) at (13.2,0) {Sortie};

	% XOR
	\node[scale=1.5, align=center] (xor1) at (1.8,0) {$\oplus$};
	\node[scale=0.75] at (xor1.north) {$k_0$};
	\node[scale=1.5, align=center] (xor2) at (4.2,0) {$\oplus$};
	\node[scale=0.75] at (xor2.north) {$k_1$};
	\node[scale=1.5, align=center] (xor3) at (6.8,0) {$\oplus$};
	\node[scale=0.75] at (xor3.north) {$k_7$};
	\node[scale=1.5, align=center] (xor4) at (9.2,0) {$\oplus$};
	\node[scale=0.75] at (xor4.north) {$k_8$};
	\node[scale=1.5, align=center] (xor5) at (11.6,0) {$\oplus$};
	\node[scale=0.75] at (xor5.north) {$k_9$};

	% lignes
	\draw (input.east) -- (round1.west);
	\draw (round1.east) -- (dots.west);
	\draw (dots.east) -- (round9.west);
	\draw (round9.east) -- (round10.west);
	\draw (round10.east) -- (output.west);
\end{tikzpicture}
\caption{fonctionnement d'AES}
\label{AES_fonctionnement}
\end{figure}

\subsection{Permutation $\Pi$}
Cette permutation est propre à AES (ne dépend pas de la clef secrète et peut être calculée à l'avance. Cela permet d'avoir un processus de chiffrement très efficace). Elle est le résultat de la composition de 3 sous-permutations (toutes inversible). Pour mieux comprendre comment ces 3 sous-permutations marchent, il faut réorganiser le bloc de 128 bits en une matrice de taille $4\times4$ où chaque cellule contient un byte.

\begin{figure}[h]
\centering
\begin{tikzpicture}
	% entrée
	\node[align=center] (s) at (0,0) {$s_0|s_1|\dots|s_{15}$};
	
	% matrice
   	\foreach \y in {-1,0,1,2} {
        	\foreach \x in {2,3,4,5} {
            	\draw (\x, -\y) rectangle (\x+1, -\y+1);
            
            	\pgfmathtruncatemacro{\number}{(\y+1)*4 + \x -2}
		\node at (\x + 0.5, -\y + 0.5){$s_{\number}$};
        }

	% fleche
	\draw[->] (s.east) -- (1.8,0);
    }
\end{tikzpicture}
\caption{Réorganisation du bloc}
\label{reorg_entre}
\end{figure}

\begin{enumerate}
	\item $\mathtt{SubBytes}$: \\
		On applique à chaque cellule du bloc une permutation $S: \{0,1\}^8 \rightarrow \{0,1\}^8$ (d'un byte vers un autre).

		\begin{figure}[h]
		\centering
		\begin{tikzpicture}
			\foreach \y in {-1,0,1,2} {
			\foreach \x in {0,1,2,3} {
				\draw (\x, -\y) rectangle (\x+1, -\y+1);
			    
				\pgfmathtruncatemacro{\number}{(\y+1)*4 + \x }
				\node at (\x + 0.5, -\y + 0.5){$s_{\number}$};
			}}

			% matrice
			\foreach \y in {-1,0,1,2} {
			\foreach \x in {6,7,8,9} {
				\draw (\x, -\y) rectangle (\x+1, -\y+1);
			    
				\pgfmathtruncatemacro{\number}{(\y+1)*4 + \x-6}
				\node at (\x + 0.5, -\y + 0.5){$\tilde{s}_{\number}$};
			}}

			% fleche
			\draw[->] (4.5,0) -- (5.5,0) node[midway, above, scale=0.8] {$\mathtt{SubBytes}$};
		\end{tikzpicture}
		\caption{Effet de $\mathtt{SubBytes}$ sur le bloc, avec $\tilde{s} = S(s)$}
		\label{illu_subbyte}
		\end{figure}

		\begin{center}RAJOUTER DEF S\end{center}

	\item $\mathtt{ShiftRows}$: \\
		Cette permutation va pour chaque colonne déplacer de manière cyclique ses élément de tel manière que la colonne $i$ subira le cycle $$\left(0 \quad (1+i)\%4 \quad (2+i)\%4 \quad (3+i)\%4\right)$$

		\begin{figure}[H]
		\centering
		\begin{tikzpicture}
			\foreach \y in {-1,0,1,2} {
			\foreach \x in {0,1,2,3} {

				\draw (\x, -\y) rectangle (\x+1, -\y+1);
			    
				\pgfmathtruncatemacro{\number}{(\y+1)*4 + \x }
				\node at (\x + 0.5, -\y + 0.5){$s_{\number}$};
			}}

			% matrice
			\foreach \y in {-1,0,1,2} {
			\foreach \x in {6,7,8,9} {	
				\pgfmathtruncatemacro{\n}{(\y+2)*10}

				\fill[black!\n] (\x, -\y) rectangle (\x+1, -\y+1);
			    
				\pgfmathtruncatemacro{\number}{(\y+1)*4+\x-6}
				\pgfmathtruncatemacro{\nnumber}{\number+\y+1}
				\pgfmathtruncatemacro{\result}{
					mod(\nnumber, 4) + 4*(\y+1)
				}
				\node at (\x + 0.5, -\y + 0.5){$s_{\result}$};
			}}

			% fleche
			\draw[->] (4.5,0) -- (5.5,0) node[midway, above, scale=0.8] {$\mathtt{ShiftRows}$};
		\end{tikzpicture}
		\caption{Effet de $\mathtt{ShiftRows}$ sur le bloc}
		\label{illu_shiftrows}
		\end{figure}

	\item $\mathtt{MixColumns}$: \\
		Pour cette permutation, on calcule dans $GF\left(2^8\right)$ (muni du polynome irréductible $x^8 + x^4 + x^3 + x + 1$ ie $100011011$) le produit matriciel (à gauche) de notre bloc par:
		
		$$
		\begin{bmatrix}
			2 & 3 & 1 & 1 \\
			1 & 2 & 3 & 1 \\
			1 & 1 & 2 & 3 \\
			3 & 1 & 1 & 2 \\
		\end{bmatrix}
		$$
		
		avec les éléments de cette matrices à comprendre comme des éléments de $GF\left(2^8\right)$ 
\end{enumerate}

\noindent Donc, en résumé : 
$$
\begin{bmatrix}
	s_{0} & s_{1} & s_{2} & s_{3} \\
	s_{4} & s_{5} & s_{6} & s_{7} \\
	s_{8} & s_{9} & s_{10} & s_{11} \\
	s_{12} & s_{13} & s_{14} & s_{15} \\
\end{bmatrix}
\overset{\Pi}{\rightarrow}
\begin{bmatrix}
	2 & 3 & 1 & 1 \\
	1 & 2 & 3 & 1 \\
	1 & 1 & 2 & 3 \\
	3 & 1 & 1 & 2 \\
\end{bmatrix}
\times
\begin{bmatrix}
	\tilde{s}_0 & \tilde{s}_1 & \tilde{s}_2 & \tilde{s}_3 \\
	\tilde{s}_5 & \tilde{s}_6 & \tilde{s}_7 & \tilde{s}_4 \\
	\tilde{s}_{10} & \tilde{s}_{11} & \tilde{s}_8 & \tilde{s}_9 \\
	\tilde{s}_{15} & \tilde{s}_{12} & \tilde{s}_{13} & \tilde{s}_{14} \\
\end{bmatrix}
$$

\subsection{Permutation $\hat{\Pi}$}
Généralement on préfère utiliser $\hat{\Pi}$ au lieu de $\Pi$  au dernier round pour avoir un algorithme de déchiffrement quasiment identique que celui de chiffrement. Avec $\hat{\Pi}$ définie tel que :
$$
\begin{bmatrix}
	s_{0} & s_{1} & s_{2} & s_{3} \\
	s_{4} & s_{5} & s_{6} & s_{7} \\
	s_{8} & s_{9} & s_{10} & s_{11} \\
	s_{12} & s_{13} & s_{14} & s_{15} \\
\end{bmatrix}
\overset{\hat{\Pi}}{\rightarrow}
\begin{bmatrix}
	\tilde{s}_0 & \tilde{s}_1 & \tilde{s}_2 & \tilde{s}_3 \\
	\tilde{s}_5 & \tilde{s}_6 & \tilde{s}_7 & \tilde{s}_4 \\
	\tilde{s}_{10} & \tilde{s}_{11} & \tilde{s}_8 & \tilde{s}_9 \\
	\tilde{s}_{15} & \tilde{s}_{12} & \tilde{s}_{13} & \tilde{s}_{14} \\
\end{bmatrix}
$$
C'est exactement $\Pi$ mais sans la permutation $\mathtt{MixColumns}$. 

\subsection{Création des clefs $k_i$}\label{clefki}
A partir d'une clef secrète $k$ (de 128 bits) il faut créer une série de clefs $k_0\dots k_{10}$.
Pour ça on sépare cette clef en 4 mots de 32 bits (4 byte) chacun.

\begin{figure}[h]
\centering
\begin{tikzpicture}
	\node[align=center] (k) at (0,0) {$10110\dots0110$};
	\draw[thick] (-1.5,-0.5) -- (1.5,-0.5) node[midway, below, scale=0.8] {128 bits};
	
	\draw[->] (1.8,0) -- (2.5,0);
	
	\foreach \x in {3,4,5,6} {
		\pgfmathtruncatemacro{\n}{\x-3}
		\draw (\x, -0.5) rectangle (\x+1, 0.5);
		\node[align=center]  at (\x+0.5, 0) {$\omega_{\n}$};
	}
\end{tikzpicture}
\caption{réorganisation des clefs en suite de mots de 32 bits}
\label{illu_clef}
\end{figure}
On définit la première clef $k_0 = \fbox{$\omega_{0,0}|\omega_{0,1}|\omega_{0,2}|\omega_{0,3}$} = k$ (ie $k_0$ est égale à la clef secrète). Ensuite, on calcule $k_i = \fbox{$\omega_{i,0}|\omega_{i,1}|\omega_{i,2}|\omega_{i,3}$}$ en fonction de $k_{i-1}$ tel que:

$$
\forall i \in \{1,2,3\} \quad 
\begin{cases}
	\omega_{i,0} &= \omega_{i-1,0} \oplus g_i(\omega_{i-1,3}) \\
	\omega_{i,j} &= \omega_{i-1,j} \oplus \omega_{i,j-1} \quad \forall j \in \{1,2,3\} 
\end{cases}
$$

\noindent Avec $g: \{0,1\}^{32} \rightarrow \{0,1\}^{32}$ une fonction tirée des standards d'AES.

\section{AES CBC}\label{sectioncbc}
\noindent\emph{Toutes les informations qui m'ont permis d'écrire cette section sont directement tirées de \cite{courscourt}.}\\

A lui seul, AES ne permet de chiffrer que des blocs de 128 bits. On pourrait se dire qu'il suffit d'appliquer AES sur l'ensemble des blocs (c'est le mode ECB). 

\begin{figure}[h]
\centering
\begin{tikzpicture}
	% message clair
	\foreach \x in {0,2} {
		\pgfmathtruncatemacro{\n}{(\x)/2+1}
		\draw (\x, 0) rectangle (\x+2, 0.5);
		\node[align=center]  at (\x+1, 0.25) {$m_{\n}$};
	}
	\node[align=center]  at (5, 0.25) {$\dots$};

	% message caché
	\foreach \x in {0,2} {
		\pgfmathtruncatemacro{\n}{(\x)/2+1}
		\draw (\x, -2.5) rectangle (\x+2, -2);
		\node[align=center]  at (\x+1, -2.25) {$c_{\n}$};
	}
	\node[align=center]  at (5, -2.25) {$\dots$};
	
	\node[draw, rectangle, align=center] (e1) at (1,-1) {$\text{AES}_k$};
	\node[draw, rectangle, align=center] (e2) at (3,-1) {$\text{AES}_k$};

	\draw[line width = 0.6mm] (1,0) -- (e1.north);
	\draw[->, line width = 0.6mm] (e1.south) -- (1, -2);
	
	\draw[line width = 0.6mm] (3,0) -- (e2.north);
	\draw[->, line width = 0.6mm] (e2.south) -- (3, -2);
\end{tikzpicture}
\caption{Fonctionement d'AES ECB, avec $\text{AES}_k$ le chiffrement d'un bloc par AES avec la clef secrète $k$}
\label{ilu_ECB}
\end{figure}

Mais, si on utilise la même clef sur plusieurs blocs, le chiffré deviens est très facile à déchiffrer. Il faudrait donc autant de clefs que de blocs pour assurer un chiffrement sécurisé. Cela doublerai la taille du message chiffré et n'est donc pas utilisé. \\

Il faut donc rajouter une couche supplémentaire pour pouvoir utiliser AES afin de chiffrer ce que l'on veut. On s'intéresse ici au mode CBC (Cipher Block Chaining). Son fonctionnement est décrit sur la figure \ref{ilu_cbc}

\begin{figure}[h]
\centering
\begin{subfigure}{\textwidth}
\centering
\begin{tikzpicture}
	% message clair
	\foreach \x in {0,2} {
		\pgfmathtruncatemacro{\n}{(\x)/2+1}
		\draw (\x, 0) rectangle (\x+2, 0.5);
		\node[align=center]  at (\x+1, 0.25) {$m_{\n}$};
	}
	\node[align=center]  at (5, 0.25) {$\dots$};

	% message caché
	\draw (-2,-3) rectangle (0,-2.5);
	\node[align=center]  at (-1, -2.75) {IV};
	\foreach \x in {0,2} {
		\pgfmathtruncatemacro{\n}{(\x)/2+1}
		\draw (\x, -3) rectangle (\x+2, -2.5);
		\node[align=center]  at (\x+1, -2.75) {$c_{\n}$};
	}
	\node[align=center]  at (5, -2.75) {$\dots$};
	
	\node[align=center, scale=1.5] (x1) at (0.5,-0.75) {$\oplus$};
	\node[draw, rectangle, align=center] (e1) at (0.5,-1.75) {$\text{AES}_k$};
	\node[align=center, scale=1.5] (x2) at (2.5,-0.75) {$\oplus$};
	\node[draw, rectangle, align=center] (e2) at (2.5,-1.75) {$\text{AES}_k$};


	\draw[->, line width = 0.6mm] (0.5,0) -- (x1.north);
	\draw[line width = 0.6mm] (x1.south) -- (e1.north);
	\draw[->, line width = 0.6mm] (e1.south) -- (0.5, -2.5);
	
	\draw[->, line width = 0.6mm] (2.5,0) -- (x2.north);
	\draw[line width = 0.6mm] (x2.south) -- (e2.north);
	\draw[->, line width = 0.6mm] (e2.south) -- (2.5, -2.5);
	

	\draw[->, line width = 0.6mm] (-0.5,-2.5) to[out=90, in=180] (x1.west);
	\draw[->, line width = 0.6mm] (1.5,-2.5) to[out=90, in=180] (x2.west);
	\node[align=center, scale=1.5, color=white] (xc) at (4.5,-0.75) {$\oplus$};
	\draw[->, line width = 0.6mm] (3.5,-2.5) to[out=90, in=180] (xc.west);

\end{tikzpicture}
\caption{Chiffrement}
\end{subfigure}

\begin{subfigure}{\textwidth}
\vspace{1cm}
\centering
\begin{tikzpicture}
	% message clair
	\draw (-2,0) rectangle (0,0.5);
	\node[align=center]  at (-1, 0.25) {IV};
	\foreach \x in {0,2} {
		\pgfmathtruncatemacro{\n}{(\x)/2+1}
		\draw (\x, 0) rectangle (\x+2, 0.5);
		\node[align=center]  at (\x+1, 0.25) {$c_{\n}$};
	}
	\node[align=center]  at (5, 0.25) {$\dots$};

	% message caché
	\foreach \x in {0,2} {
		\pgfmathtruncatemacro{\n}{(\x)/2+1}
		\draw (\x, -3) rectangle (\x+2, -2.5);
		\node[align=center]  at (\x+1, -2.75) {$m_{\n}$};
	}
	\node[align=center]  at (5, -2.75) {$\dots$};
	
	\node[draw, rectangle, align=center] (e1) at (0.5,-0.7) {$\text{AES}^{-1}_k$};
	\node[align=center, scale=1.5] (x1) at (0.5,-1.75) {$\oplus$};
	\node[draw, rectangle, align=center] (e2) at (2.5,-0.7) {$\text{AES}^{-1}_k$};
	\node[align=center, scale=1.5] (x2) at (2.5,-1.75) {$\oplus$};

	\draw[line width = 0.6mm] (0.5,0) -- (e1.north);
	\draw[->, line width = 0.6mm] (e1.south) -- (x1.north);
	\draw[->, line width = 0.6mm] (x1.south) -- (0.5, -2.5);
	
	\draw[line width = 0.6mm] (2.5,0) -- (e2.north);
	\draw[->, line width = 0.6mm] (e2.south) -- (x2.north);
	\draw[->, line width = 0.6mm] (x2.south) -- (2.5, -2.5);

	\draw[->, line width = 0.6mm] (-0.5,0) to[out=-90, in=180] (x1.west);
	\draw[->, line width = 0.6mm] (1.5,0) to[out=-90, in=180] (x2.west);
	\node[align=center, scale=1.5, color=white] (xc) at (4.5,-1.75) {$\oplus$};
	\draw[->, line width = 0.6mm] (3.5,0) to[out=-90, in=180] (xc.west);
\end{tikzpicture}
\caption{Déchiffrement}
\end{subfigure}
\caption{Fonctionement d'AES CBC, avec $\text{AES}_k$ le chiffrement d'un bloc par AES avec la clef secrète $k$}
\label{ilu_cbc}
\end{figure}

On remarque que le premier bloc du chiffré est un Initialization Vector (IV). C'est un bloc choisit aléatoirement. Ensuite, un deuxième point important de ce mode d'utilisation d'AES (ou de tout autre méthode de chiffrement par bloc) est qu'il faut que la taille du message en clair soit exactement un multiple de 128 bits. La solution est de rajouter un padding. C'est à dire que l'on complète le message pour que sa taille soit exactement égale au prochain multiple de 128 bits (si le message est déjà un multiple de 128 bits on rajoute 16 byte de padding). Il peut prendre plein de forme différente, on peut compléter avec des $0$, des bits aléatoires... La seul règle importante est que le dernier byte du bloc doit contenir le nombre de byte de padding qui ont été rajouté (entre 0 et 15). \\

Pour ma part mon padding suivra la règle suivante : tous les bytes du padding ont la même valeurs (donc celle du dernier byte).
Par exemple s'il manque 3 bytes à mon message pour être un multiple de 16 byte (i.e 128 bites) alors je rajoute à la fin du message $\fbox{02|02|02}$. Si c'est déjà un multiple de 16 byte je rajoute à la fin\\ $\fbox{15|15|15|15|15|15|15|15|15|15|15|15|15|15|15|15}$.\\

J'avais essayé d'implémenter la padding classique (remplir de $0$, par exemple pour un padding de 3 bytes cela donne $\fbox{00|00|02}$) mais je devais mal implémenter quelque chose car je n'arrivais pas à me munir d'un padding oracle (voir \ref{padoracle}) alors que la théorie veux que ça ne change rien.

\subsection{Mon implémentation}
Dans le cade de ma mission je dois implémenter AES CBC en RUST. 
J'ai choisit de ne pas réimplémenter AES car j'avais du mal à implémenter des éléments relatif à $g$ (voir \ref{clefki}) mais aussi car une implémentation d'AES est très régulièrement inutilisable en réalité car trop facile à attaquer. Rien que des informations tels que la consommation électrique de l'ordinateur, le temps qu'il met à répondre ou encore le champ électromagnétique qu'il émet sont suffisant pour casser mon implémentation. 

J'ai donc implémenté le mode CBC avec le padding énoncé à la fin de \ref{sectioncbc}. J'ai choisit pour simplifier la tâche de me restreindre à chiffrer des chaînes de caractères. De là est apparu un pseudo problème, le type Char en RUST peut faire de 1 à 4 byte. Mais,au déchiffrement, ne connaissant pas le nombre de byte associé à chaque caractères, j'ai été dans l'obligation de faire comme si chaque charactère ne faisait qu'un byte. Donc si mon message n'est pas uniquement écris avec des caractères ASCI (1 byte) alors j'aurais de la perte d'information. \\
Par exemple si je chiffre et déchiffre le message : "Je vais à l'école" j'obtiendrai un message du type "Je vais \$£ l'\&ùcole".

J'ai choisit d'ignorer ce problème étant donné qu'il n'est du qu'au format de l'entrée.

\subsection{Padding oracle attack}\label{padoracle}
Dans cette section, j'explique comment j'ai attaqué AES CBC et de manière équivalente tout les modes de chiffrement non autentifié (qui ne fournissent pas une preuve d'authenticité du chiffré) et qui utilisent un padding. \\ 

L'attaque que j'ai mené repose sur un principe simple. Pour chaque algorithme de chiffrement qui utillisent un padding, n'importe qui pourra toujours avoir accès à un padding oracle (On n'a encore jamais trouvé de contre exemple). 

Avoir accès à un padding oracle c'est pouvoir déduire du comportement du serveur si le padding du message que je lui demande de déchiffrer est correct (on peut par exemple déduire cette information du temps que mets le serveur à nous répondre).
Je vais montré ci dessous qu'à partir du moment ou on a accès à ce genre d'information on peut casser le chiffré.

\subsubsection{Déchiffrer un bloc}
En reprenant la figure \ref{ilu_cbc} et en l'adaptant pour un bloc c on obtien la figure \ref{cbcdec1bloc}. 

\begin{figure}[h]
\centering
\begin{tikzpicture}
	\fill[red!20, opacity=0.5] (1.7,-0.1) rectangle (4.3,-3.35);
	% message clair
	\draw (0,0) rectangle (2,0.5);
	\node[align=center] at (1, 0.25) {IV};
	\draw (2,0) rectangle (4,0.5);
	\node[align=center] at (3,0.25) {c};

	% message caché
	\draw (2, -3) rectangle (4, -2.5);
	\node[align=center]  at (3, -2.75) {m};

	\node[draw, rectangle, align=center] (e2) at (3,-0.7) {$\text{AES}^{-1}_k$};
	\node[align=center, scale=1.5] (x2) at (3,-1.75) {$\oplus$};
	
	\draw[line width = 0.6mm] (3,0) -- (e2.north);
	\draw[->, line width = 0.6mm] (e2.south) -- (x2.north);
	\draw[->, line width = 0.6mm] (x2.south) -- (3, -2.5);

	\draw[->, line width = 0.6mm] (1,0) to[out=-90, in=180] (x2.west);

	\node[align=center] (pad_or) at (6,-2.75) {Padding Oracle};
	\draw[->, line width = 0.6mm] (4,-2.75) -- (pad_or.west);

\end{tikzpicture}
\caption{Déchiffrement d'un bloc, (en rouge: ce qui ne nous est pas accessible)}
\label{cbcdec1bloc}
\end{figure}

Le but de l'attaque est de trouver un IV tel que le padding du bloc déchiffré m est valide. En effet, si on arrive à trouver un IV tel que $m = \fbox{15|\dots|15}$ alors 
$$ 
\text{IV} \oplus \fbox{15|\dots|15} = \text{AES}^{-1}_{k}\left(\text{c}\right)
$$
On aura donc réussi à déchiffrer c! Pour arriver à trouver cet IV on procède de la manière suivante : \\

On pose IV = \fbox{00|00|00|00|00|00|00|00|00|00|00|00|00|00|00|b} avec b un byte quelconque. On fait varier b (256 possibilités) jusqu'à obtenir une réponse positive du padding oracle. Une fois arrivé à cette étape il existe 2 situation dans lesquelles on peut se trouver :

\begin{enumerate}
	\item Dans le cas le plus courant on aura m = \fbox{??|??|$\dots$|??|00}. C'est ce qu'on cherche!
	\item Mais il se peut aussi que l'avant dernier byte permette à plus d'un padding d'être correcte. En effet, si ce byte vaut 01 alors il existe un byte b tel que l'IV produise un m = \fbox{??|??|$\dots$|??|01|01}.
\end{enumerate}

Ce deuxième cas est gênant mais il est facile de vérifier dans quel cas on se trouve en modifiant l'avant dernier byte de l'IV.
En effet si en modifiant l'avant dernier byte de l'IV produit une réponse favorable du padding oracle cela signifie qu'on est dans le premier cas sinon on est dans le deuxième. 
\begin{align*}
	&\fbox{??|??|$\dots$|42|00} \rightarrow \text{padding valide}\\
	&\fbox{??|??|$\dots$|42|01} \rightarrow \text{padding invalide}
\end{align*}

Une fois à cette étape on peut créer un IV qu'on appelle ZIV (zeroing IV). Cet IV permet de mettre à 0 les bytes que l'on change dans m. Dans notre cas on a directement IV = ZIV. \\

On sait maintenant comment créer le premier ZIV, supposons que l'on soit cappable de créer le n-ième ZIV : $\text{ZIV}_n$ (cet IV assure que les n derniers bytes de m valent 0). Essayons de trouver $\text{ZIV}_{n+1}$. \\

On pose $\text{IV} = \text{ZIV}_n + \fbox{00|$\dots$|00|b|n|$\dots$|n}$ avec n bytes \fbox{n} et b, un byte quelconque. Cet IV permet d'avoir $\text{m} = \fbox{??|??|\dots|??|n|$\dots$|n}$ car 0 est l'élément neutre de $\oplus$ dans $\mathbb{Z}/2\mathbb{Z}$. \\
Comme à la première étape (celle qui sert à trouver le premier ZIV), on fait varier b (256 possiblités) jusqu'à avoir une réponse positive du padding oracle. En effectuant la même vérification qu'à la première étape, on est en mesure de trouver b tel que $\text{m} = \fbox{??|??|$\dots$|??|n|$\dots$|n|}$ avec cette fois ci n+1 byte \fbox{n}. Alors on remarque que $\text{ZIV}_{n+1} = \text{IV} \oplus \fbox{00|$\dots$|00|n|$\dots$|n}$ car $m \oplus \fbox{00|$\dots$|00|n|$\dots$|n} = \fbox{??|$\dots$|??|00|$\dots$|00}$. \\

Ainsi, on est en mesure de trouver un IV ($\text{ZIV}_{16}$) tel que $m=\fbox{00|$\dots$|00}$ et donc comme on l'a dit en début de section et comme on peut le voir sur la figure \ref{pad_ora_blo} on peut déchiffrer le bloc c car si $a \oplus b = 0$ alors $a = b$ donc $\text{AES}_k^{-1}(\text{c}) = \text{ZIV}_{16}$.

\begin{figure}[h]
\centering
\begin{tikzpicture}
	\fill[red!20, opacity=0.5] (1.7,-0.1) rectangle (4.3,-3.35);

	% message clair
	\draw (0,0) rectangle (2,0.5);
	\node[align=center, scale=0.8] at (1, 0.25) {$\text{AES}_k^{-1}(\text{c})$};
	\draw (2,0) rectangle (4,0.5);
	\node[align=center] at (3,0.25) {c};

	% message caché
	%\draw (2, -3) rectangle (4, -2.5);
	%\node[align=center]  at (3, -2.75) {$00|\dots|00$};
	\draw (2,-3) rectangle (2.66,-2.5) node[align=center] at (2.33,-2.75) {00};
	\draw (2.66,-3) rectangle (3.33,-2.5) node[align=center] at (3,-2.75) {$\dots$};
	\draw (3.33,-3) rectangle (4,-2.5) node[align=center] at (3.62,-2.75) {00};

	\node[draw, rectangle, align=center] (e2) at (3,-0.7) {$\text{AES}^{-1}_k$};
	\node[align=center, scale=1.5] (x2) at (3,-1.75) {$\oplus$};
	
	\draw[line width = 0.6mm] (3,0) -- (e2.north);
	\draw[->, line width = 0.6mm] (e2.south) -- (x2.north);
	\draw[->, line width = 0.6mm] (x2.south) -- (3, -2.5);

	\draw[->, line width = 0.6mm] (1,0) to[out=-90, in=180] (x2.west);

\end{tikzpicture}
\caption{Déchiffrement d'un bloc, (en rouge: ce qui ne nous est pas accessible)}
\label{pad_ora_blo}
\end{figure}

\subsubsection{Généralisation à n blocs}
On rappelle le shéma de déchifrement d'AES CBC sur la figure \ref{dechif_cbc}. On remarque alors que si on est en mesure de trouver $\text{AES}^{-1}_k(c_i)$ alors on est cappable de trouver $m_i$ $\forall i$. En effet $\text{AES}^{-1}_k(c_i) \oplus c_{i-1} = m_i$. Donc en déchiffran chaque bloc avec une attack par padding oracle on peut déchiffrer l'entierté du chiffré.   
\begin{figure}[h]
\centering
\begin{tikzpicture}
	\fill[red!20, opacity=0.5] (-0.7,-0.1) rectangle (5.5,-3.35);

	% message clair
	\draw (-2,0) rectangle (0,0.5);
	\node[align=center]  at (-1, 0.25) {IV};
	\foreach \x in {0,2} {
		\pgfmathtruncatemacro{\n}{(\x)/2+1}
		\draw (\x, 0) rectangle (\x+2, 0.5);
		\node[align=center]  at (\x+1, 0.25) {$c_{\n}$};
	}
	\node[align=center]  at (5, 0.25) {$\dots$};

	% message caché
	\foreach \x in {0,2} {
		\pgfmathtruncatemacro{\n}{(\x)/2+1}
		\draw (\x, -3) rectangle (\x+2, -2.5);
		\node[align=center]  at (\x+1, -2.75) {$m_{\n}$};
	}
	\node[align=center]  at (5, -2.75) {$\dots$};
	
	\node[draw, rectangle, align=center] (e1) at (0.5,-0.7) {$\text{AES}^{-1}_k$};
	\node[align=center, scale=1.5] (x1) at (0.5,-1.75) {$\oplus$};
	\node[draw, rectangle, align=center] (e2) at (2.5,-0.7) {$\text{AES}^{-1}_k$};
	\node[align=center, scale=1.5] (x2) at (2.5,-1.75) {$\oplus$};

	\draw[line width = 0.6mm] (0.5,0) -- (e1.north);
	\draw[->, line width = 0.6mm] (e1.south) -- (x1.north);
	\draw[->, line width = 0.6mm] (x1.south) -- (0.5, -2.5);
	
	\draw[line width = 0.6mm] (2.5,0) -- (e2.north);
	\draw[->, line width = 0.6mm] (e2.south) -- (x2.north);
	\draw[->, line width = 0.6mm] (x2.south) -- (2.5, -2.5);

	\draw[->, line width = 0.6mm] (-0.5,0) to[out=-90, in=180] (x1.west);
	\draw[->, line width = 0.6mm] (1.5,0) to[out=-90, in=180] (x2.west);
	\node[align=center, scale=1.5, opacity=0] (xc) at (4.5,-1.75) {$\oplus$};
	\draw[->, line width = 0.6mm] (3.5,0) to[out=-90, in=180] (xc.west);


\end{tikzpicture}
\caption{Déchiffrement d'AES CBC avec en rouge ce qui ne nous est pas accessible}
\label{dechif_cbc}
\end{figure}

\section{AES GCM}
\noindent\emph{Toutes les informations qui m'ont permis d'écrire cette section sont directement tirées de \cite{courscourt}.}\\


On s'est intéressé dans la section précédente au mode CBC en montrant qu'AES CBC était facilement attaquable et donc pas fiable. On s'intéresse ici au mode GCM (Galois Counter Mode), le mode d'utilisation le plus courant d'AES. Comme pour AES CBC, AES GCM fait des opérations sur des blocs de 128 bits pour permettre de chiffrer de grands fichiers. Mais, à la différence d'AES CBC, AES GCM utilise un algorithme d'authentification en parallle du chiffrement ce qui permet d'assurer que le chiffré n'a pas été changé. Cette deuxième partie est essentielle car il a été montré qu'un algorithme de chiffrement non authentifié est quasiment systématiquement attaquable.

\subsection{CTR} \label{CTR}
Comme CBC, CTR (Counter) est un mode de manipulation des blocs qui permet de chiffrer des données avec des algorithme de chiffrement par blocs (comme AES) tout en garantisant un certain niveau de sécurité. CTR est le mode utilisé dans GCM mais sans l'authentification.Il est assez similaire à CBC mais à comme gros avantage de ne pas obliger de rajouter un padding à la fin des données clairs.

Son fonctionnement est décrit sur la figure \ref{aesctr}. 

\begin{figure}[h]
\centering
\begin{tikzpicture}
	% message clair
	\foreach \x in {0,2} {
		\pgfmathtruncatemacro{\n}{(\x)/2+1}
		\draw (\x, 0) rectangle (\x+2, 0.5);
		\node[align=center]  at (\x+1, 0.25) {$m_{\n}$};
	}
	\node[align=center]  at (5, 0.25) {$\dots$};

	% message caché
	\draw (-2,-3.25) rectangle (0,-2.75);
	\node[align=center]  at (-1, -3) {IV};
	\foreach \x in {0,2} {
		\pgfmathtruncatemacro{\n}{(\x)/2+1}
		\draw (\x, -3.25) rectangle (\x+2, -2.75);
		\node[align=center]  at (\x+1, -3) {$c_{\n}$};
	}
	\node[align=center]  at (5, -3) {$\dots$};
	
	\node[draw, rectangle, align=center, scale = 0.75] (x1) at (1,-1.25) {$\text{AES}_k$};
	\node[align=center, scale=1.5] (e1) at (1,-2) {$\oplus$};
	\node[draw, rectangle, align=center, scale = 0.75] (x2) at (3,-1.25) {$\text{AES}_k$};
	\node[align=center, scale=1.5] (e2) at (3,-2) {$\oplus$};

	\draw[line width = 0.6mm] (x1.south) -- (e1.north);
	\draw[->, line width = 0.6mm] (e1.south) -- (1, -2.75);
	
	\draw[line width = 0.6mm] (x2.south) -- (e2.north);
	\draw[->, line width = 0.6mm] (e2.south) -- (3, -2.75);
	
	\node[align=center, scale = 0.75] (c1) at (1.5,-0.5) {$+1$};
	\node[align=center, scale = 0.75] (c2) at (3.5,-0.5) {$+1$};

	
	\draw[-, line width = 0.6mm] (-0.5,-2.75) -- (-0.5, -1);
	\draw[-, line width = 0.6mm] (-0,-0.5) -- (c1.west);
	\draw[-, line width = 0.6mm] (-0.5,-1) to[out=90, in=180] (0, -0.5);

	\draw[-, line width = 0.6mm] (c1.east) -- (c2.west);
	\draw[->, line width = 0.6mm] (c2.east) -- (4.5, -0.5);

	\draw[->, line width = 0.6mm] (0.5,-0.5) to[out=0, in=90] (x1.north);
	\draw[->, line width = 0.6mm] (2.5,-0.5) to[out=0, in=90] (x2.north);

	\draw[white, line width = 1mm] (0.1,-0.5) -- (0.3,-0.5);
	\draw[white, line width = 1mm] (2.1,-0.5) -- (2.3,-0.5);
	\draw[->, line width = 0.6mm] (0.25,0) to[out=270, in=180] (e1.west);
	\draw[->, line width = 0.6mm] (2.25,0) to[out=270, in=180] (e2.west);

\end{tikzpicture}
\caption{Fonctionnement d'AES CTR, avec $\text{AES}_k$ le chiffrement d'un bloc par AES avec la clef secrète $k$, \emph{Le +1 signifie qu'on incrémente de 1 l'IV généré aléatoirement.}
}
\label{aesctr}
\end{figure}

\subsection{GMAC} \label{GMAC}

Pour obtenir GCM il faut rajouter une étape d'authentification. Elle est fait par un algorithme incrémental GMAC (Galois Message Authentification Code). Cet algorithme produit au cours du chiffrement des blocs un Tag qui résume de manière sécurisé toutes les informations sur la donné à chiffré. L'intérêt de cela est que chaque entrée produira un Tag unique. Donc si quelqu'un a modifié le chiffré, alors il y aura une erreur lors du déchiffrement.Cela permet de garantir que la donné que vous déchiffrez est bien celle que l'on souhaite récupérer.

\begin{figure}[h]
\centering
\begin{tikzpicture}

	% message caché
	\draw (-2,-3.25) rectangle (0,-2.75);
	\node[align=center]  at (-1, -3) {IV};
	\foreach \x in {0,2} {
		\pgfmathtruncatemacro{\n}{(\x)/2+1}
		\draw (\x, -3.25) rectangle (\x+2, -2.75);
		\node[align=center]  at (\x+1, -3) {$c_{\n}$};
	}
	\node[align=center]  at (5, -3) {$\dots$};
	\node[align=center] (x) at (5, -3.9) {$\dots$};
	\node[align=center] (xx) at (5, -5.2) {$\dots$};

	\draw (6, -3.25) rectangle (8, -2.75);
	\node[align=center]  at (7, -3) {$c_{n}$};
	\draw (8, -3.25) rectangle (10, -2.75);
	\node[align=center]  at (9, -3) {Tag};

	\node[draw, rectangle, align=center, scale = 0.75] (add) at (-1,-3.9) {AAD};
	\node[draw, rectangle, align=center, scale = 0.75] (len) at (7,-4.8) {Taille du chiffré et de l'AAD};

	
	\node[align=center] (x0) at (0,-3.9) {$\times \text{H}$};
	\node[align=center] (x1) at (1,-3.9) {$\bigoplus$};
	\node[align=center] (x2) at (2,-3.9) {$\times \text{H}$};
	\node[align=center] (x3) at (3,-3.9) {$\bigoplus$};
	\node[align=center] (x4) at (4,-3.9) {$\times \text{H}$};
	\node[align=center] (x5) at (6,-3.9) {$\times \text{H}$};
	\node[align=center] (x6) at (7,-3.9) {$\bigoplus$};
	\node[align=center] (x7) at (8,-3.9) {$\times \text{H}$};
	\node[align=center] (x8) at (9,-3.9) {$\bigoplus$};
	\node[align=center] (x9) at (10,-3.9) {$\times \text{H}$};
	\node[align=center] (x10) at (11,-3.9) {$\bigoplus$};

	\draw[-, line width = 0.6mm] (add.east) -- (x0.west);
	\draw[->, line width = 0.6mm] (x0.east) -- (x1.west);
	\draw[-, line width = 0.6mm] (x1.east) -- (x2.west);
	\draw[->, line width = 0.6mm] (x2.east) -- (x3.west);
	\draw[-, line width = 0.6mm] (x3.east) -- (x4.west);
	\draw[-, line width = 0.6mm] (x4.east) -- (x.west);
	\draw[-, line width = 0.6mm] (x.east) -- (x5.west);
	\draw[->, line width = 0.6mm] (x5.east) -- (x6.west);
	\draw[-, line width = 0.6mm] (x6.east) -- (x7.west);
	\draw[->, line width = 0.6mm] (x7.east) -- (x8.west);
	\draw[-, line width = 0.6mm] (x8.east) -- (x9.west);
	\draw[->, line width = 0.6mm] (x9.east) -- (x10.west);

	\node[draw, rectangle, align=center, scale = 0.75] (aesiv) at (3,-5.2) {$\text{AES}_k$};

	\draw[-, line width = 0.6mm] (-1.7, -3.25) -- (-1.7, -4.7);
	\draw[-, line width = 0.6mm] (-1.7, -4.7) to[out=270, in=180] (-1.2,-5.2);
	\draw[->, line width = 0.6mm] (-1.2,-5.2) -- (aesiv.west);
	\draw[-, line width = 0.6mm] (aesiv.east) -- (xx.west);
	\draw[-, line width = 0.6mm] (xx.east) -- (10.5,-5.2);
	\draw[->, line width = 0.6mm] (10.5,-5.2) to[out=0, in=270] (x10.south);

	\draw[->, line width = 0.6mm] (1, -3.25) -- (x1.north);
	\draw[->, line width = 0.6mm] (3, -3.25) -- (x3.north);
	\draw[->, line width = 0.6mm] (7, -3.25) -- (x6.north);
	\draw[->, line width = 0.6mm] (len.east) to[out=0, in=270] (x8.south);
	\draw[-, line width = 0.6mm] (x10.north) -- (11,-3.4);
	\draw[-, line width = 0.6mm] (11,-3.4) to[out=90, in=0] (10.5,-3);
	\draw[->, line width = 0.6mm] (10.5,-3) -- (10, -3);

\end{tikzpicture}
\caption{Fonctionnement du GMAC, avec $\text{AES}_k$ le chiffrement d'un bloc par AES avec la clef secrète $k$, et $\times \text{H}$ la multiplication dans $GF\left(2^{128}\right)$ par $\text{H} = \text{AES}_k\left({0}^{128}\right)$.}
\label{gmac}
\end{figure}

Dans la figure \ref{gmac}, une nouvelle entrée, appelée AAD (Additional Authenticated Data), est introduite. L'AAD est une donnée que l'on souhaite authentifier, mais pas nécessairement chiffrer. Par exemple, imaginons que vous envoyez un mot de passe accompagné d'une adresse web. Vous voudriez chiffrer le mot de passe pour le protéger, tout en laissant l'adresse en clair. Cependant, si l'adresse n'est pas authentifiée, un attaquant pourrait la modifier, et vous ne le sauriez pas lors du déchiffrement. L'AAD permet de protéger contre ce risque en garantissant que l'adresse n'a pas été altérée."

\subsection{GCM}

GCM est la combinaison du mode CTR (voir \ref{CTR}) et de la création d'un Tag avec GMAC (voir \ref{GMAC}). Combiné à AES, cela nous donne l'algorithme de chiffrement authentifié le plus largement utilisé. Son fonctionnement est décrit sur la figure \ref{aesgcm}.

\begin{figure}[h]
\centering
\begin{tikzpicture}
	\fill[green!20, opacity=0.5] (-0.8,-0.2) rectangle (7.7,-2.55);
	\fill[red!20, opacity=0.5] (-2.2,-3.4) rectangle (11.5,-5.6);

	% message clair
	\foreach \x in {0,2} {
		\pgfmathtruncatemacro{\n}{(\x)/2+1}
		\draw (\x, 0) rectangle (\x+2, 0.5);
		\node[align=center]  at (\x+1, 0.25) {$m_{\n}$};
	}
	\node[align=center]  at (5, 0.25) {$\dots$};
	\node[align=center] (x) at (5, -0.5) {$\dots$};

	\draw (6, 0) rectangle (8, 0.5);
	\node[align=center]  at (7, 0.25) {$m_{n}$};
	
	\node[draw, rectangle, align=center, scale = 0.75] (x1) at (1,-1.25) {$\text{AES}_k$};
	\node[align=center] (e1) at (1,-2) {$\bigoplus$};
	\node[draw, rectangle, align=center, scale = 0.75] (x2) at (3,-1.25) {$\text{AES}_k$};
	\node[align=center] (e2) at (3,-2) {$\bigoplus$};
	\node[draw, rectangle, align=center, scale = 0.75] (x3) at (7,-1.25) {$\text{AES}_k$};
	\node[align=center] (e3) at (7,-2) {$\bigoplus$};



	\draw[line width = 0.6mm] (x1.south) -- (e1.north);
	\draw[->, line width = 0.6mm] (e1.south) -- (1, -2.75);
	
	\draw[line width = 0.6mm] (x2.south) -- (e2.north);
	\draw[->, line width = 0.6mm] (e2.south) -- (3, -2.75);

	\draw[line width = 0.6mm] (x3.south) -- (e3.north);
	\draw[->, line width = 0.6mm] (e3.south) -- (7, -2.75);
	
	\node[align=center, scale = 0.75] (c1) at (1.5,-0.5) {$+1$};
	\node[align=center, scale = 0.75] (c2) at (3.5,-0.5) {$+1$};
	
	\draw[-, line width = 0.6mm] (-0.5,-2.75) -- (-0.5, -1);
	\draw[-, line width = 0.6mm] (-0,-0.5) -- (c1.west);
	\draw[-, line width = 0.6mm] (-0.5,-1) to[out=90, in=180] (0, -0.5);

	\draw[-, line width = 0.6mm] (c1.east) -- (c2.west);
	\draw[-, line width = 0.6mm] (c2.east) -- (4.5, -0.5);

	\draw[->, line width = 0.6mm] (0.5,-0.5) to[out=0, in=90] (x1.north);
	\draw[->, line width = 0.6mm] (2.5,-0.5) to[out=0, in=90] (x2.north);
	\draw[-, line width = 0.6mm] (x.east) -- (6.5, -0.5);
	\draw[->, line width = 0.6mm] (6.5,-0.5) to[out=0, in=90] (x3.north);

	\draw[white, line width = 1mm] (0.1,-0.5) -- (0.3,-0.5);
	\draw[white, line width = 1mm] (2.1,-0.5) -- (2.3,-0.5);
	\draw[white, line width = 1mm] (6.1,-0.5) -- (6.3,-0.5);
	\draw[->, line width = 0.6mm] (0.25,0) to[out=270, in=180] (e1.west);
	\draw[->, line width = 0.6mm] (2.25,0) to[out=270, in=180] (e2.west);
	\draw[->, line width = 0.6mm] (6.25,0) to[out=270, in=180] (e3.west);


	% message caché
	\draw (-2,-3.25) rectangle (0,-2.75);
	\node[align=center]  at (-1, -3) {IV};
	\foreach \x in {0,2} {
		\pgfmathtruncatemacro{\n}{(\x)/2+1}
		\draw (\x, -3.25) rectangle (\x+2, -2.75);
		\node[align=center]  at (\x+1, -3) {$c_{\n}$};
	}
	\node[align=center]  at (5, -3) {$\dots$};
	\node[align=center] (x) at (5, -3.9) {$\dots$};
	\node[align=center] (xx) at (5, -5.2) {$\dots$};

	\draw (6, -3.25) rectangle (8, -2.75);
	\node[align=center]  at (7, -3) {$c_{n}$};
	\draw (8, -3.25) rectangle (10, -2.75);
	\node[align=center]  at (9, -3) {Tag};

	\node[draw, rectangle, align=center, scale = 0.75] (add) at (-1,-3.9) {AAD};
	\node[draw, rectangle, align=center, scale = 0.75] (len) at (7,-4.8) {Taille du chiffré et de l'AAD};

	
	\node[align=center] (x0) at (0,-3.9) {$\times \text{H}$};
	\node[align=center] (x1) at (1,-3.9) {$\bigoplus$};
	\node[align=center] (x2) at (2,-3.9) {$\times \text{H}$};
	\node[align=center] (x3) at (3,-3.9) {$\bigoplus$};
	\node[align=center] (x4) at (4,-3.9) {$\times \text{H}$};
	\node[align=center] (x5) at (6,-3.9) {$\times \text{H}$};
	\node[align=center] (x6) at (7,-3.9) {$\bigoplus$};
	\node[align=center] (x7) at (8,-3.9) {$\times \text{H}$};
	\node[align=center] (x8) at (9,-3.9) {$\bigoplus$};
	\node[align=center] (x9) at (10,-3.9) {$\times \text{H}$};
	\node[align=center] (x10) at (11,-3.9) {$\bigoplus$};

	\draw[-, line width = 0.6mm] (add.east) -- (x0.west);
	\draw[->, line width = 0.6mm] (x0.east) -- (x1.west);
	\draw[-, line width = 0.6mm] (x1.east) -- (x2.west);
	\draw[->, line width = 0.6mm] (x2.east) -- (x3.west);
	\draw[-, line width = 0.6mm] (x3.east) -- (x4.west);
	\draw[-, line width = 0.6mm] (x4.east) -- (x.west);
	\draw[-, line width = 0.6mm] (x.east) -- (x5.west);
	\draw[->, line width = 0.6mm] (x5.east) -- (x6.west);
	\draw[-, line width = 0.6mm] (x6.east) -- (x7.west);
	\draw[->, line width = 0.6mm] (x7.east) -- (x8.west);
	\draw[-, line width = 0.6mm] (x8.east) -- (x9.west);
	\draw[->, line width = 0.6mm] (x9.east) -- (x10.west);

	\node[draw, rectangle, align=center, scale = 0.75] (aesiv) at (3,-5.2) {$\text{AES}_k$};

	\draw[-, line width = 0.6mm] (-1.7, -3.25) -- (-1.7, -4.7);
	\draw[-, line width = 0.6mm] (-1.7, -4.7) to[out=270, in=180] (-1.2,-5.2);
	\draw[->, line width = 0.6mm] (-1.2,-5.2) -- (aesiv.west);
	\draw[-, line width = 0.6mm] (aesiv.east) -- (xx.west);
	\draw[-, line width = 0.6mm] (xx.east) -- (10.5,-5.2);
	\draw[->, line width = 0.6mm] (10.5,-5.2) to[out=0, in=270] (x10.south);

	\draw[->, line width = 0.6mm] (1, -3.25) -- (x1.north);
	\draw[->, line width = 0.6mm] (3, -3.25) -- (x3.north);
	\draw[->, line width = 0.6mm] (7, -3.25) -- (x6.north);
	\draw[->, line width = 0.6mm] (len.east) to[out=0, in=270] (x8.south);
	\draw[-, line width = 0.6mm] (x10.north) -- (11,-3.4);
	\draw[-, line width = 0.6mm] (11,-3.4) to[out=90, in=0] (10.5,-3);
	\draw[->, line width = 0.6mm] (10.5,-3) -- (10, -3);


\end{tikzpicture}
\caption{Fonctionnement d'AES GCM avec en vert CTR et en rouge GMAC}
\label{aesgcm}
\end{figure}


\noindent Pour résumer, AES GCM prend 4 entrées : 
\begin{enumerate}
	\item un nonce (ou IV) généré aléatoirement (que l'on choisit de mettre au début du chiffré pour réduir le nombre d'objets à stocker).
	\item une clef (de préférence générée aléatoirement)
	\item des données à chiffrer et authentifier 
	\item des données à authentifier (on peut aussi ne pas en fournir)
\end{enumerate}
\noindent et fournit 2 sorties :
\begin{enumerate}
	\item Le chiffré de la donné à chiffrer
\item Le tag associé aux entrées (mis à la fin du chiffré)
\end{enumerate}
\section{SoftHSM}

Le but des cryptographe est de créer des problèmes facile à résoudre quand on a la clefs mais beaucoup trop long à casser le cas inverse. Donc, dans beaucoup de cas trouver un moyen de récupérer cette clef est beaucoup plus raisonnable que de chercher une faille dans le cryptosystème. Il faut donc trouver un moyen sécuriser de garder nos clefs, i.e il faut un coffre fort moderne. \\

Pour ça, il existe les HSM (Hardware Securty Module) qui sont des dispositif physique dédié à la gestion, au stockage et à la protection des clefs cryptographique. Il est conçu pour exécuter des opérations cryptographiques, telles que le chiffrement, le déchiffrement, la signature numérique et la gestion de clés, de manière sécurisée.


\begin{figure}[h]
	\centering
	\includegraphics[width=.7\textwidth]{img/hsm.png}
	\caption{HSM de Thales}
	\label{hsmthales}
\end{figure}

Ici on ne n'intéressera pas réellement aux HSM mais plutôt aux SoftHSM, une implémentation logicielle d'un HSM. Il permettent de développer des programmes, faire des tests en ammont d'une utilisation d'un HSM. \\

Dans un premier temps j'ai du me familiariser avec ce nouvel object, puis, j'ai du regarder les solutions en rust qui nous permettent de communiquer avec des HSM, les documenter et les tester (via un SoftHSM). \\


Pour communiquer avec un SoftHSM j'ai du me plonger dans la doc du logiciel. Avant de pouvoir entammer des opérations cryptographiques il faut créer un envronement dédié dans le SoftHSM. \\
Pour le créer la commande est la suivante :
\begin{verbatim}
sudo softhsm2-util --init-token 
		--slot <slot-num> 
		--token <token-label>
\end{verbatim}
et pour le supprimer :
\begin{verbatim}
sudo softhsm2-util --delete-token --label <token-label>
\end{verbatim}
Ici il faut bien comprendre qu'un token est une émulation d'un HSM (on peut émuler plusieur HSM sur un SoftHSM), le slot est un point d'entrée d'un HSM, il simule l'endroit ou l'on insère nos informations dans un HSM). \\
Après avoir initialiser mon softHSM, je peux communiquer avec lui en utilisant le standard pkcs11. C'est cette partie plus tard que je devrais programmer en rust. Pour le moment, j'utilise openssl, un logiciel qui me permet directement de communiquer avec le SoftHSM. Après avoir étudier la documentation, j'en ai tiré les informations suivantes :
Pour créer une clef je dois utiliser : 
\begin{verbatim}
sudo pkcs11-tool --module /usr/lib/softhsm/libsofthsm2.so 
		-l -p <usr-PIN> 
		--keygen --key-type <enc-mech> 
		--id <clef-id> 
		--label <clef-label>
\end{verbatim}
Avec <enc-mech> qui prend la forme AES:16, AES:32, ect. Pour la supprimer on utilise la commande : 
\begin{verbatim}
sudo pkcs11-tool --module /usr/lib/softhsm/libsofthsm2.so 
-l -p <usr-PIN> 
-b --type secrkey 
--id <clef-ID>
\end{verbatim}

Maintenant qu'on a réussit à créer des clefs, on peut les utiliser pour chiffrer et déchiffrer des données. Pour le faire, il faut utiliser :
\begin{verbatim}
sudo pkcs11-tool --module /usr/lib/softhsm/libsofthsm2.so 
		--login -p <usr-PIN> 
		--encrypt 
		--id <key-ID> 
		-m AES-CBC-PAD 
		--iv <iv-value> 
		-i <input file> 
		-o <output file>

sudo pkcs11-tool --module /usr/lib/softhsm/libsofthsm2.so 
		--login -p <usr-PIN> 
		--decrypt 
		--id <key-ID> 
		-m AES-CBC-PAD 
		--iv <iv-value> 
		-i <input file> 
		-o <output file>
\end{verbatim}

Pour la suite, j'utilise la crate cryptoki de Rust que j'ai trouvée grâce à \cite{bddrustcrypto}, ce qui me permet de garantir sa fiabilité.
La documentation de cette crate n'étant pas encore faite, j'ai créé un fichiers tuto dans lequel je réalise toutes les opérations que je pourrais être amené à faire sur le SoftHSM, c'est-à-dire créer et supprimer des clés ainsi que chiffrer et déchiffrer des données. Pour y arriver, j'ai parcouru le code source de la documentation et je me suis aidé d'outils tels que ChatGPT. Après beaucoup d'essais, j'ai fini par obtenir un tutoriel fonctionnel.\\

La dernière étape consistait à vérifier que les résultats produits par mon programme correspondaient bien aux attentes. Pour cela, il est nécessaire de tester le programme avec des vecteurs de test. Chaque vecteur de test fournit une clé, un IV (Initialisation Vector), des données à chiffrer, le résultat chiffré attendu, et, si le programme le permet, des données à authentifier ainsi que le TAG correspondant. L'objectif de ces vecteurs est de comparer les sorties théoriques avec celles produites par notre algorithme. Pour que les tests soient validés, il faut que ces dernières soient identiques.

Pour faire ces test j'ai eu une grosse difficulté : je ne peux pas imposer la valeur d'une clef via mon programme (c'est une donnée protégé donc le softhsm me l'interdit). Pour contourner ce problème, je lance un script bash dans mon code rust qui crée la clef avec openssl. Ce script est le suivant : 
\begin{verbatim}
echo -n <key-value> > aes_key.txt
xxd -r -p aes_key.txt > aes_key.bin
sudo pkcs11-tool --module /usr/lib/softhsm/libsofthsm2.so 
		-l -p <usr-PIN> --write-object
aes_key.bin 
		--type secrkey --key-type <enc-mech> 
		--id <clef-id> 
		--label <clef-label>
\end{verbatim}
Mon programme à passé tout les test, et donc, grâce à mon tutoriel je suis maintenant capable de remplacer openssl par un programme "maison" en rust.
\section{Signature}
Ensuite, pour compléter mes connaissance en cryptographie, j'ai eu à implémenter 2 algorithme de signature. Comme pour le TAG qu'on créer dans AES GCM (voir \ref{GMAC}), une signature électronique permet d'authentifier une donnée et de garantir son intégrité. Mais, contrairement au Tag, elle peut aussi servir comme une preuve dans un context légal. Avec une signature numérique, l'expéditeur ne peut pas nier avoir signé la donnée. En effet on verra plus tard que les algorithme utilisés nécessitent des clefs assymétrique : une clef publique et une clef privée. Comme seul l'expéditeur connait la clef privée, il est le seul  pouvoir signer le document.

\subsection{RSA}
\subsubsection{Génération des clefs}
\noindent Pour créer la clef publique et la clef privée il faut :
\begin{enumerate}
	\item Poser $n = pq$ avec $p$ et $q$ deux nombres premiers
	\item Calcluler $\varphi(n)$ (l'indicatrice d'euler), le nombre d'élément inversible de $\mathbb{Z}/n\mathbb{Z}$ i.e $\varphi\left( n\right) = (p-1)(q-1)$
	\item Choisir $e$, un entier premier avec $\varphi(n)$
	\item Calculer $d = e^{-1}$ dans $\mathbb{Z}/\varphi(n)\mathbb{Z}$ (existe car $e \wedge \varphi(n) = 1$) 
\end{enumerate}
On a alors une clef privée = $(n, d)$ et une clef publique = $(n,e)$. Pour des raison de sécurité, il faut choisir $n$ et $d$ grand (au moins 3072 bits) mais $e$ peut être petit.On remarque alors le grand défault de RSA :  les clefs sont extrèmement grande. C'est la principale raison pour laquelle on essaye d'éviter d'utiliser RSA quand il faut générer plusieurs clefs. Ce problème ne fera que devenir de plus en plus important avec le temps car il faut constamment addapter la taille des clefs avec l'apparition des nouveaux composants.

\subsubsection{Signer avec RSA}
Pour une donnée quelquonque $m$ on calcule $h = \text{hash}(m)$ avec hash une fonction de hashage tel que 
$$
\forall m, \, \text{hash}(m) < n
$$ 
\emph{Si cette condition n'est pas vérifié rien ne garanti que la signature poura être vérifié.}
Enfin pour calculer la signature $s$ associé à m, on chiffre h en calculant 
$$
s = h^d \, \lbrack n \rbrack
$$
On remarque bien qu'on utilise la clef privé pour créer la signature.

\subsubsection{Vérifier l'intégrité des données}
N'importe qui en possession de la clef publique $(n, e)$ est en mesure de dire si le message $\tilde{m}$ qu'il a reçu avec la signature $s$ est authentique (i.e $\tilde{m} = m$). \\
Pour ça il doit calculer $\tilde{h} = \text{hash}(\tilde{m})$ et déchiffrer la signature en calculant $s^e \, \lbrack n \rbrack$. Son message est authentique si et seulement si 
$$
\tilde{h} = s^e \, \lbrack n \rbrack
$$
Car $s^e = h^{ed} = h \lbrack n \rbrack$, donc $\tilde{h} = s^e \, \lbrack n \rbrack \Leftrightarrow \tilde{h} = h \lbrack n \rbrack$. Cette dernière égalité modulaire souligne bien l'importance de la condition sur le hash.




\subsection{Courbes elliptiques avec Ed25519}
Nous avons vu qu'il était possible de faire de la signature numérique avec RSA mais que ce cryptosystème n'a qu'un intéret très limité à la vu de la taille gigantesque des clefs. Une alternative présenté ici permet est bien plus performante que RSA.
\subsubsection{Courbe elliptique}
\noindent Pour un corp $K$, on peut définir une courbe ellitique par une équation de la forme 
$$
y^2 + a_1xy + a_3y = x^3 + a_2x^2 +a_4x + a_6
$$
avec $(a_1,\, \dots, a_6) \in K^6$. On sait que ces courbes sont symétrique par rapport à l'axe des abscices (donc si $P$ est sur la courbe alors $-P$ aussi). \\

\begin{figure}[h]
	\centering
	\includegraphics[width=.5\textwidth]{img/courbe1.png}
	\caption{Courbe $y^2 = x^3 - x + 9$ sur $\mathbb{R}$}
	\label{courbe1}
\end{figure}



\label{methodecorde}Un problème compliqué à résoudre sur ces courbes est de trouver les points rationnels de la courbe. Par contre, on sait qu'avec deux points $(U, V)$ rationnels tels que $U \neq -V$, on peut facilement en trouver deux autres. En effet, la droite qui passe par $U$ et $V$ coupera la courbe en un nouveau point $W$ rationnel (on a le qatrième point par symétrie).
De là on définit l'addition sur une coube elliptique par 
$$
U + V = - W
$$

\begin{figure}[h]
	\centering
	\includegraphics[width=.5\textwidth]{img/courbe1op.png}
	\caption{$P + Q$ sur $y^2 = x^3 - x + 9$ sur $\mathbb{R}$ avec $P = (-1-3)$ et $Q = (1,3)$}
	\label{courbe1op}
\end{figure}


\label{methodetangente}On peut étendre cette définition en partant d'un point rationnel $P$ de la croube elliptique avec une ordonnée non nulle. Cette fois ci on prend sa tangente (on fait tendre $U$ et $V$ vers $P$, la droite qui passait par $U$ et $V$ tend bien vers la tangente passant par $P$). Alors cette tangente va bien couper la courbe en un deuxième point rationnel.Cette extention nous permet de définir $P+P$. \\

\noindent\emph{On appelle respectivement ces méthodes la méthode de la corde et de la tangente.}

\subsubsection{Courbe elliptique sur un espace à dimension finie}
En cryptographie, on définit les courbes elliptiques sur des espaces à dimension finie de dimmension $p$ : $\mathbb{Z}/p\mathbb{Z}$. Avec $p$ un premier suppérieur à 3. \\
la courbe elliptique $(E)$ sur $ \mathbb{Z}/p\mathbb{Z}$ vérifiera 
$$
y^2 = x^3 + ax + b
$$
avec $(a,b) \in \left(\mathbb{Z}/p\mathbb{Z}\right)^2$ et $4a^3 + 27b^2 \neq 0$, cette condition permet d'éviter les singularités. \\

\begin{figure}[h]
	\centering
	\includegraphics[width=.8\textwidth]{img/courbezpz.png}
	\caption{Courbe $y^2 = x^3 -6x + 2$ sur $ \mathbb{Z}/59\mathbb{Z}$}
	\label{courbezpz}
\end{figure}



\noindent On définit le groupe $\left(E\left( \mathbb{Z}/p\mathbb{Z} \right), +\right)$ par :
\begin{itemize}
	\item $E\left( \mathbb{Z}/p\mathbb{Z} \right)$ l'ensembles des points rationnels de la courbes $E$ définit sur $\mathbb{Z}/p\mathbb{Z}$
	\item $\mathcal{O}$ l'élément neutre pour l'addition définit comme le point de la courbe à l'infinit. Alors
		$$
		\forall P \in E\left( \mathbb{Z}/p\mathbb{Z} \right), \, P + \mathcal{O} = \mathcal{O}+P=P
		$$
	\item Posant $P = (x_1, y_1)$ et $Q = (x_2, y_2)$, on définit l'addition par ces trois règles pour calcluler $P+Q$ :
	\begin{enumerate}
		\item Si $x_1 \neq x_2$ on utilise la méthode de la corde (voir \ref{methodecorde})
		\item Sinon si $P = Q$ on utilise la méthode de la tangente (voir \ref{methodetangente})
		\item Sinon ($P = -Q$) alors on pose 
		$$
		P+Q = \mathcal{O}
		$$
	\end{enumerate}
	Voir \cite{courslong} si vous voulez voir les formules complètes.
\end{itemize}


\subsubsection{Ed25519}\label{courbeed}

On s'intéresse maintenat à un cas particulier des courbes elliptiques (toujours sur $ \mathbb{Z}/p\mathbb{Z}$). On définit les courbes d'Edward comme des courbes elliptiques pouvant se mettre sous la forme 
$$
x^2 + y^2 = 1 + dx^2y^2
$$
avec $d \in \mathbb{Z}/p\mathbb{Z}$ et $d \neq 0,\, 1$. On peut alors définir + par
$
\forall (P,Q) = ((x_1,y_1),(x_2,y_2)) \in \left(E\left( \mathbb{Z}/p\mathbb{Z} \right)\right)^2
$
$$
P + Q = \left(\frac{x_1y_2+x_2y_1}{1+dx_1x_2y_1y_2},\, \frac{y_1y_2-x_1y_2}{1-dx_1x_2y_1y_2}\right), \quad \mathcal{O} = \left(0,1\right) 
$$
Cette simplicité d'implémentation permet de limiter certaines attaques. 

A partir de maintenant, on se concentre sur la courbe d'Edward avec $d = 3709570\\59346694393431380835087545651895421138798432190163887855330859402\\83555$ définit sur $ \mathbb{Z}/p\mathbb{Z}$ avec $p = 2^{255}-19$.


\subsubsection{Génération des clefs}
\noindent Pour créer la clef publique et la clef privée il faut :
\begin{enumerate}
	\item choisir un algorithme de hashage produisant un résultat sur 512 bits (généralement Sha512)
	\item créer une chaine $k$ de 256 bits (de préférence généré aléatoirement).
	\item calculer $h = hash(k)$ et puis $s$ à partir des 256 premiers bits de $h$ avec la convention "little endians".
	\item calculer $A = sB$ avec $B$\footnote{Pour des raisons de simplicité, caclulatoire, on utilise une convention différente que celle présentée dans ici \ref{courbeed} mais elle est détaillé dans \cite{eddsa}} un point de Ed25519 donné dans \cite{eddsa}\\
\end{enumerate}

On a alors la clef privée $k$ et la clef publique $\text{compress}(A)$\footnote{compresse() est l'algorithme de compression de EdDSA. Dans notre cas, c'est une chaine de 256 bits. les 255 premiers bits sont les 255 premiers bits de la coordonée y du point en convention "little endians" (comme y<p, son bit de poids fort est tout le temps nul). Le dernier bit de la chaine vaut 1 si le point est négatif, 0 sinon}. On remarque bien que contrairement à RSA EdDSA permet d'avoir des clefs bien plus petite (256 bits chacune)
\subsubsection{Signer avec Ed25519}
Pour signer des données avec les courbes d'Edward on utilise l'algorithme EdDSA décrit plus précisément dans \cite{eddsa}.
Il y a de paramètre généreaux propre à l'agorithme EdDSA sur Ed25519 mais je ne les présentes pas. Pour les voir, je vous invite à lire la Section 5.1 de \cite{eddsa}.\\

L'idée principale de cet algorithme est de générer à partir et du message et de la clef privée un point $R = rB$.
Pour calculer $r$, il faut calculer le hash modulo $L$\footnote{$L$ est une constante introduite dans \cite{eddsa} et vaut $2^{252}+2774231777737235353585193779088364\\8493$} des 256 derniers bits de du hash de la clef privé $h = hash(k)$ concaténé\footnote{symbolisé par $\Vert$} à la donnée $m$ à signer.
$$
r = \text{hash}\left(h[32..64] \, \Vert \, m\right) \, \lbrack L \rbrack
$$
Ensuite on calcule $\tilde{h}$ tel que
$$
\tilde{h} = \text{hash}\left(\text{compress}(R) \, \Vert \, \text{compress}(A) \, \Vert \, m\right) \, \lbrack L \rbrack
$$
Enfin, notant $x = r+\tilde{h}s \lbrack L \rbrack$ en représentation "little endians" alors la signature est donnée par :
$$
\text{signature}_{\text{Ed25519}} = \text{compress}(R) \, \Vert \, x
$$

On remarque que la signature fait 512 bits et à besoins de la clef privée et de la clef publique (dérive dirrectement de la clef privée) pour la générer.

\subsubsection{Vérifier l'intégrité des données}
N'importe qui en possession de la clef publique $A$ est en mesure de dire si le message $\tilde{m}$ qu'il a reçu avec la signature est authentique (i.e $\tilde{m} = m$). \\
Pour ça il doit décomprésser\footnote{Algorithme assez intuitif mais avec des astuces de calcul détaillé dans \cite{eddsa}. Il consiste à récupérer la coordonnée $y$, vérifier qu'il existe bien des points avec cette coordonée appartenant à la courbe, puis choisir le bon point graçe au signe} le point $R$ en récupérant les 256 premiers bits de la signature. 
Ensuite il faut récupérer l'entier $x$ écrit en convention "little endian" dans les 256 derniers bits de la signature et calculer 
$$
\tilde{\tilde{h}} =  \text{hash}\left(\text{compress}(R) \, \Vert \, \text{compress}(A) \, \Vert \, \tilde{m}\right) \, \lbrack L \rbrack
$$
Enfin, le message sera authentique si et seulement si on a l'égalité dans le groupe $\left(E\left( \mathbb{Z}/p\mathbb{Z} \right), +\right)$
$$
xB = R + \tilde{\tilde{h}}A
$$
Car
\begin{align*}
	xB = R + \tilde{\tilde{h}}A \; &\Rightarrow \; rB + \tilde{h}sB = R+\tilde{\tilde{h}}A \\
							&\Rightarrow \; R + \tilde{h}A = R+\tilde{\tilde{h}}A \\
							&\Rightarrow \; \left(\tilde{h} - \tilde{\tilde{h}}\right)A = 0 \\
	\footnote{Argument géométrique}&\Rightarrow\; \tilde{h} = \tilde{\tilde{h}} \\
							&\Rightarrow \; m = \tilde{m}
\end{align*}
On remarque qu'on a bien besoins que de la clef publique $A$ pour vérifier la signature.

 


\section{Mise en place d'un programme de chiffrement/déchiffrement}
\subsection{Contexte}
Maintenant que j'ai pris connaissance des algorithmes pour chiffrer et signer des données, je dois mettre en place une solution écrite en Rust qui permettra de chiffrer et de déchiffrer des fichierss. Cette solution devra permettre d'utiliser soit AES-GCM, soit ChaCha20-Poly1305 (un autre algorithme de chiffrement non détaillé précédemment).
Une optimisation que je pourrais envisager serait de proposer une version qui chiffrerait "au fil de l'eau", c'est-à-dire de manière progressive, bloc par bloc, à mesure que les données sont lues ou écrites. Cette méthode présente l'avantage de maintenir un coût constant en espace mémoire, car elle ne nécessite pas de charger l'intégralité du fichiers en mémoire avant de le chiffrer. \\


Pour exécuter ce programme de chiffrement, il suffira d'utiliser les commandes suivantes : 
\begin{verbatim}
cat clair.data | ./rucrypt options > enc.data
cat enc.data | ./rudecrypt options > dec.data
\end{verbatim}
Les options permettront de choisir l'algorithme utilisé. Pour le moment peuvent soit valoir "aes" pour AES-GCM, ou bien "cha" pour ChaCha20-Poly1305 ou encore "aes\_stream" pour la version au fil de l'eau d'AES-GCM.\\


\noindent\emph{le programme de chifrement s'appelle rucrypt et celui de déchifrement rudecrypt}

\subsection{Mise en place}
Cette fois-ci, contrairement à Ed25519, je n'ai pas tout reprogrammé. J'ai décidé d'utiliser des crates de confiance, largement éprouvées. Pour les identifier, je me suis aidé d'un site qui référence toutes les solutions couramment utilisées pour la cryptographie en Rust \cite{bddrustcrypto}. J'utilise AES 256 (voir le tableau \ref{AES-versions}). Pour chaque algorithme, je dois donc générer, avant le chiffrement, une clé de 32 octets (256 bits) et un nonce (vecteur d'initialisation) de 12 octets (96 bits). Il est démontré que cacher le nonce n'a aucun intérêt en termes de sécurité. Je place donc le nonce en clair avant le texte chiffré. \\

On pourrait s'arrêter là, mais il est possible d'ajouter un niveau de sécurité supplémentaire. Actuellement, le chiffrement et le déchiffrement se font avec une seule clé (c'est-à-dire une clé symétrique). Le problème de cette symétrie est que toute personne ayant accès à cette clé peut lire le message en clair. Dans le cadre de ma mission, cela représente une potentielle faille. En effet, le but final de ce programme est de permettre la création de sauvegardes chiffrées de données. Il est donc préférable d'utiliser une clé asymétrique (une pour le chiffrement et une pour le déchiffrement). Dans ce cas de figure, tout le monde peut effectuer une sauvegarde de ses fichierss, mais seules les personnes autorisées pourront les récupérer, cela permet de garder le contrôle sur les flux. Pour cette raison, je génère une clé privée et une clé publique RSA, avec laquelle je chiffre ma clé symétrique. Ainsi, seule la personne en possession de la clé privée pourra déchiffrer le document. Pour plus de simplicité, je place la clé symétrique chiffrée avant le nonce.


$$
\text{rucrypt(data)} \rightarrow \fbox{RSA(clef symétrique) | nonce | data chiffré}
$$

\section{Wireguard}
Le but ici est de créer à l'aide de Wireguard un flux chiffré entre plusieurs machines pour permettre à ces machines de communiquer de manière simple et sécurisé.
\subsection{Configuration}
Pour le serveur et les clients il faut créer un fichier de configuration dans \\\verb+\ect\wireguard\wg0.conf+ (On n'est pas obligé de l'appeller \verb+wg0+). A l'intérieur, le fichier est séparé en au moins 2 sections :
\begin{itemize}
\item une qui commence par \verb+[Interface]+, elle contient les informations de la machine, comme la clef privée et adresse.
\item une autre (ou plus) qui commence par \verb+[Peer]+ et qui contient les informations des machines (comme la clef publique et les adresses authorisées) avec lesquelles on va communiquer. \\
\end{itemize}

Pour chaque machine, il faudra générer une paire de clefs. Pour cela, WireGuard nous fournit un outil. Il permet de créer une clé privée et de dériver la clé publique à partir de celle là.

\begin{verbatim}
wg genkey > privatekey
wg pubkey < privatekey > publickey
\end{verbatim}


\subsubsection{Serveur}
Pour la configuration du serveur, il faut rajouter le port utilisé pour communiquer (typiquement 51820). Une configuration complete côté serveur pourra ressembler par exemple à

\begin{verbatim}
[Interface]
PrivateKey = uKlFiRw6goZdHuPNeThISu7sGqr8JH3U+LrQ3VbaBXk= 
Address = 10.8.8.254/24
ListenPort = 51820

[Peer]
PublicKey = 4N2H/21U4kYpS5KZlQfjOjddlvs7bgr0Z3ZHHBqF8lU=
AllowedIPs = 10.8.8.1/32

[Peer] 
PublicKey = NIeEDlBPTJrM7389yaRKzXWJeAEicmrFm0zkfhnDVCo=  
AllowedIPs = 10.8.8.2/32
\end{verbatim}
Chaque peer est un client avec lequel peut communiquer le serveur. Attention, il faut bien penser à àctiver l'IP forwarding du serveur pour lui permettre aux clients de communiquer entre eux (en pas uniquement au serveur). \\
Pour l'activer il faut décommenter la ligne \verb+net.ipv4.ip_forward=1+ du fichier \\\verb+/etc/sysctl.conf+.

\subsubsection{Clients}
La configuration d'un client est quasiment identique à celle d'un serveur à la différence qu'il n'y a qu'un peer : le serveur. Elle ressemblera typiquement à 
\begin{verbatim}
[Interface]
PrivateKey = uBl+tmfka8ukXcEV3vz5wtYinhZpLOEiAOe+gwhke28=
Address = 10.8.8.1

[Peer]
PublicKey = GigedMPFFe+r7SB4s48vnEnPREiAXX/TLB07hBuAGm4= 
Endpoint = 192.168.218.180:51820
AllowedIPs = 10.8.8.0/24
PersistentKeepalive = 25
\end{verbatim}
La dernière ligne permet d'éviter d'avoir des problèmes mais n'est pas obligatoire.
\subsection{Mise en place}
Pour activer la configuration il suffit de lancer \verb+wg-quick up wg0+ et pour la désactiver \verb+wg-quick down wg0+. Maintenant, si on veut qu'elle s'active automatiquement quand la machine s'allume il faut lancer \verb+sudo systemctl start wg-quick@wg0+(et \verb+sudo systemctl stop wg-quick@wg0+ pour que ça ne soit plus le cas). \\

Attention, pour l'instant les clefs et les fichiers de configuration sont accessibles à tout le monde. Il faut veiller à supprimer les clefs (on en a plus besoijns une fois qu'elles sont dans les fichiers de configurations) et à restreindre l'accès aux fichiers de configuration. 
\begin{verbatim}
sudo mkdir -p /etc/wireguard/
sudo chmod 700 /etc/wireguard
\end{verbatim}

\printbibliography
\end{document}
